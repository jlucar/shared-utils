{"version":3,"file":"index.module.mjs","sources":["../src/constants/CATEGORIES.ts","../src/fetchConfigs/transformationOptions.ts","../src/fetchConfigs/transformToNested.ts","../src/fetchConfigs/transformResponse.ts","../src/fetchConfigs/transformToConfigValues.ts","../src/createConfigsFromJson.ts","../src/parseSource/parseSource.ts","../src/parseSource/parseSourceConfigs.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport enum ConfigCategory {\n  Setting = `setting`,\n  Translation = `translation`,\n  UI = `ui`,\n  Feature = `feature`\n}\n\nexport enum ConfigCategoryPlurals {\n  Setting = `settings`,\n  Translation = `translations`,\n  UI = `ui`,\n  Feature = `features`\n}\n\n/* eslint-enable: no-unused-vars */\nconst CATEGORIES = {\n  [ConfigCategory.Setting]: {\n    plural: ConfigCategoryPlurals.Setting,\n    label: `Setting`,\n    labelPlural: `Settings`,\n    order: 1,\n  },\n  [ConfigCategory.Translation]: {\n    plural: ConfigCategoryPlurals.Translation,\n    label: `Translation`,\n    labelPlural: `Translations`,\n    order: 2,\n  },\n  [ConfigCategory.UI]: {\n    plural: ConfigCategoryPlurals.UI,\n    label: `UI`,\n    labelPlural: `UI`,\n    order: 3,\n  },\n  [ConfigCategory.Feature]: {\n    plural: ConfigCategoryPlurals.Feature,\n    label: `Feature`,\n    labelPlural: `Features`,\n    order: 4,\n  },\n}\n\nexport { CATEGORIES }\n","import lodash from 'lodash'\n\nconst { assign, mapValues } = lodash\n\nexport type TransformationOptions = {\n  nested: boolean,\n  categorized: boolean,\n}\n\nconst getTransformationOptions = (options: Partial<TransformationOptions> = {}): TransformationOptions => {\n\n  options = mapValues(options, () => true)\n\n  const opts: TransformationOptions = {\n    nested: false,\n    categorized: false,\n  }\n\n  return assign(opts, options)\n}\n\nexport { getTransformationOptions }\n","import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst transformToNested = object => {\n\n  const transformed = {}\n\n  each(object, (value, key) => {\n    setWith(transformed, key, value, Object)\n  })\n\n  return transformed\n}\n\nexport { transformToNested }\n","import lodash from 'lodash'\n\nimport { CATEGORIES } from '../constants'\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, get } = lodash\n\nconst helpTransformResponse = (response, callback = null) => {\n\n  const transformed = {}\n\n  each(response, (value, key) => {\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, value)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    transformed[key] = value\n  })\n\n  return transformed\n}\n\nconst transformResponse = (response, opts = {}, configs = null) => {\n\n  const options = getTransformationOptions(opts)\n\n  const transformed = helpTransformResponse(response, key => {\n\n    if (options.categorized) {\n\n      const config = get(configs, key)\n\n      if (config) {\n        key = `${CATEGORIES[config.category].plural}.${key}`\n      }\n    }\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(transformed)\n  }\n\n  return transformed\n}\n\nexport { transformResponse }\n","import lodash from 'lodash'\n\nimport { CATEGORIES } from '../constants'\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, has } = lodash\n\nconst transformFromConfigsToResponse = (configs, callback = null) => {\n\n  const response = {}\n\n  each(configs, (config, key) => {\n\n    let value = has(config, `value`) ? config.value : config.default\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, config)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    response[key] = value\n  })\n\n  return response\n}\n\nconst transformToConfigValues = (configs, opts = {}) => {\n\n  const options = getTransformationOptions(opts)\n\n  const response = transformFromConfigsToResponse(configs, (key, config) => {\n\n    key = options.categorized ? `${CATEGORIES[config.category].plural}.${key}` : key\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(response)\n  }\n\n  return response\n}\n\nexport { transformToConfigValues }\n","import lodash from 'lodash'\n\nimport type {\n  Config,\n  StandardizedConfigs,\n} from './types'\n\nconst { each, isBoolean, isObject, last, split, startsWith, trimEnd } = lodash\n\n/**\n * TODO: This function doesn't know how to handle configs with an empty array value (preSelectedNewsletters) and the config will just be ignored\n */\nconst flattenJsonObject = (object: object, initialPathPrefix: string = ``) => {\n\n  function flatten(object, initialPathPrefix) {\n    if (!object || typeof object !== `object`) {\n      return [{ [initialPathPrefix]: object }]\n    }\n\n    const prefix = initialPathPrefix\n      ? Array.isArray(object)\n        ? initialPathPrefix\n        : `${initialPathPrefix}.`\n      : ``\n\n    return Object.keys(object)\n      .flatMap((key) =>\n        flatten(\n          object[key],\n          Array.isArray(object) ? `${prefix}[${key}]` : `${prefix}${key}`,\n        ),\n      )\n      .reduce((acc, path) => ({ ...acc, ...path }), [])\n  }\n\n  const flattenedObject = flatten(object, initialPathPrefix)\n\n  const configs = {}\n  each(flattenedObject, (value, key) => {\n    const splitKey = split(key, `.`)\n    const lastPart = last(splitKey)\n    if (startsWith(lastPart, `#`)) {\n      if (lastPart === `#value`) {\n        configs[trimEnd(key, `.#value`)] = value\n      }\n    } else {\n      configs[key] = value\n    }\n  })\n\n  return configs\n}\n\nconst createConfigsFromJson = (json: object): StandardizedConfigs => {\n\n  const configs = {}\n\n  const flattenJson = flattenJsonObject(json)\n\n  each(flattenJson, (value, key) => {\n\n    let defaultValue = value\n    if (isObject(value)) {\n      defaultValue = value[`#value`]\n    }\n\n    const config: Config = {\n      default: defaultValue,\n    }\n\n    if (isBoolean(defaultValue)) {\n      config.type = `switch`\n    }\n\n    configs[key] = config\n  })\n\n  return configs\n}\n\nexport { createConfigsFromJson }\n","import lodash from 'lodash'\n\nimport type { Component, ComponentOptions, Components, Config, ConfigObject, Configs, Source, StandardizedConfigs } from '../types'\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nexport type SourceConfigs = {\n  getComponents?: () => Promise<Components>,\n  getConfigs?: () => Promise<Configs>,\n  getLabel?: () => string | Promise<string | undefined>,\n  getName?: () => string | Promise<string | undefined>,\n  source?: string\n}\n\nexport type HelperFunctions = ReturnType<typeof getHelpers>\n\nexport type Definitions = {\n  [key: string]: DefinitionComponent\n}\n\n/* eslint-disable no-unused-vars */\nexport type DefinitionComponent = {\n  getConfigs?: (_: HelperFunctions) => Configs\n  getSettings?: (_: HelperFunctions) => Configs\n  getTranslations?: (_: HelperFunctions) => Configs\n  getUI?: (_: HelperFunctions) => Configs,\n  getFeatures?: (_: HelperFunctions) => Configs,\n  getOptions?: () => Component\n}\n\n/* eslint-enable no-unused-vars */\n\nconst getType = (config: Config) => {\n  if (typeof config === `object`) {\n    switch (typeof config.default) {\n      case `boolean`:\n        return `switch`\n    }\n  }\n\n  return `input`\n}\n\nconst standardizeConfig = (key: string, config: Config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config as ConfigObject\n}\n\nconst parseConfig = (key: string, config: Config, options: Partial<ConfigObject> = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  } as ConfigObject, config, options) as ConfigObject\n}\n\nconst parseConfigs = (\n  configs: Configs,\n  options: Partial<ConfigObject> = {},\n  // eslint-disable-next-line no-unused-vars\n  callback?: (key: string, config: Config) => void,\n) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return lodash.get(config, `key`, key)\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    callback && callback(key, config)\n\n    return parseConfig(key, config, options)\n  }) as StandardizedConfigs\n}\n\nconst parseUniqueConfigs = (set: Configs, configs: Configs, options: Partial<ConfigObject>) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set: Configs, configs: Configs, options: Partial<ComponentOptions>) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components: Components, component: string) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs: Configs, callback = null) => {\n\n    const walked: StandardizedConfigs = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name: string, label: string, configs: Configs, type = `group`) => {\n\n    let path: string = groupTypes[type].path\n    let replacement: ComponentOptions = {}\n\n    each(configs, config => {\n      if (typeof config === `object` && config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name: string, configs: Configs) => {\n    return walkConfigs(configs, (key: string, config: Config) => {\n\n      if (typeof config === `object`) {\n        if (config.visibleIf) {\n          config.visibleIf = `${name}.${config.visibleIf}`\n        }\n\n        config.longLabel = `${startCase(name)} ⇢ ${config.longLabel ? config.longLabel : (config.label ? config.label : startCase(key))}`\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n    })\n  }\n\n  const addGroup = (\n    name: string,\n    label: string,\n    configs: Configs,\n    nesting = true,\n    type = `group`,\n    /* eslint-disable-next-line no-unused-vars */\n    callback?: (_: string, _2: Config) => void,\n  ) => {\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key: string, config: ConfigObject) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name: string, label: string, configs: Configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        typeof config === `object` && lodash.set(config, `visibleIf`, `${name}.enabled`)\n      }\n    })\n\n    return configs as StandardizedConfigs\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  type AddFieldCallbackInnerFuncType = (key: string, config: Config) => void\n\n  const addField = (\n    key: string,\n    // eslint-disable-next-line no-unused-vars\n    callback?: (arg: { insert: AddFieldCallbackInnerFuncType, modify: AddFieldCallbackInnerFuncType }) => void,\n  ) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    const prettyKey = startCase(key)\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      longLabel: `${prettyKey} ⇢ Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      longLabel: `${prettyKey} ⇢ Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      longLabel: `${prettyKey} ⇢ Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      longLabel: `${prettyKey} ⇢ Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      longLabel: `${prettyKey} ⇢ Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      longLabel: `${prettyKey} ⇢ Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert: AddFieldCallbackInnerFuncType = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        const parsedConfig = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n\n        parsedConfig.longLabel = `${prettyKey} ⇢ ${parsedConfig.label}`\n\n        fields[key] = parsedConfig\n      }\n\n      const modify: AddFieldCallbackInnerFuncType = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback && callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label: string, configs: Configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = (definitions: Definitions) => {\n\n  const configs: Configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getFeatures,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options: Partial<ConfigObject> = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n\n      if (getFeatures) {\n        parseConfigsIntoCollection(configs, getFeatures(helpers), assign(options, {\n          category: `feature`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key: string, component?: ComponentOptions) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component) as ComponentOptions\n}\n\nconst parseComponents = (components: Components) => {\n  return mapValues(components, (component, key: string) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  }) as Components\n}\n\nconst parseComponentsFromConfigs = (configs: Configs, structure: Components = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: Components = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (typeof config === `object` && has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }: SourceConfigs) => {\n\n  const name = getName ? await getName() : source\n  const label = getLabel ? await getLabel() : startCase(name)\n\n  const options: Source = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const config = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(config, grabComponents)\n    merge(options, {\n      config,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { parseSource, SourceError }\n","import { parseSource, SourceConfigs } from './parseSource'\n\nconst parseSourceConfigs = async (source: string, stack: SourceConfigs) => {\n\n  const parsedSource = await parseSource({\n    source,\n    ...stack,\n  })\n\n  return parsedSource.configs\n}\n\nexport { parseSourceConfigs }\n"],"names":["_CATEGORIES","ConfigCategory","ConfigCategoryPlurals","CATEGORIES","Setting","plural","label","labelPlural","order","Translation","UI","Feature","assign","lodash","mapValues","getTransformationOptions","options","nested","categorized","each","setWith","transformToNested","object","transformed","value","key","Object","get","response","opts","configs","callback","newKey","newValue","helpTransformResponse","config","category","has","transformToConfigValues","_callback","transformFromConfigsToResponse","isBoolean","isObject","last","split","startsWith","trimEnd","createConfigsFromJson","json","flattenJson","initialPathPrefix","flattenedObject","flatten","_ref","prefix","Array","isArray","keys","flatMap","reduce","acc","path","_extends","splitKey","lastPart","flattenJsonObject","defaultValue","default","type","kebabCase","mapKeys","merge","set","size","startCase","unset","getType","skipDefaultCheck","Error","parseConfig","standardizeConfig","docLink","docLinkText","hint","parseConfigs","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","toggleable","description","rootKey","parseSource","getComponents","getConfigs","getLabel","getName","source","_temp5","name","_temp3","_temp2","grabComponents","_temp","Promise","resolve","then","_getConfigs","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","_parseConfigsAndCompo","parseComponents","getFeatures","getSettings","getTranslations","getUI","helpers","groupTypes","group","tab","walkConfigs","walked","addGroup","nesting","setComponentGroup","replacement","groupExpanded","groupType","holder","addNested","visibleIf","longLabel","addFeature","enabled","addTab","addField","fields","prettyKey","isVisible","styleClasses","required","disabled","readonly","hasAutoFocus","pattern","insert","parsedConfig","modify","getHelpers","e","reject","error","_this","message","this","parseSourceConfigs","stack","parsedSource"],"mappings":"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"}