{"version":3,"file":"index.module.mjs","sources":["../src/convertToNested.ts","../src/createConfigs.ts","../src/createConfigsFromJson.ts","../src/createGroup.ts","../src/createFeature.ts","../src/createField.ts","../src/createSection.ts","../src/createSubSection.ts","../src/parseOnboarder.ts","../src/parseSource.ts"],"sourcesContent":["import lodash from 'lodash'\n\nimport { Configs } from '../../types'\n\nconst { each, setWith } = lodash\n\nconst convertToNested = (object: Configs) => {\n\n  const nested: Configs = {}\n\n  each(object, (value, key) => {\n    setWith(nested, key, value, Object)\n  })\n\n  return nested\n}\n\nexport { convertToNested }\n","import lodash from 'lodash'\n\nimport type { Configs, NestedConfigs } from '../../types'\n\nconst { has } = lodash\n\nconst createConfigs = (obj: NestedConfigs): Configs => {\n\n  function walk(into, obj, prefix = []) {\n    Object.entries(obj).forEach(([key, val]) => {\n      if (typeof val === `object` && !Array.isArray(val) && !has(val, `default`)) walk(into, val, [...prefix, key]);\n      else into[[...prefix, key].join(`.`)] = val;\n    });\n  }\n\n  const dotObj = {};\n  walk(dotObj, obj);\n\n  return dotObj;\n}\n\nexport { createConfigs }\n","import lodash from 'lodash'\n\nimport type {\n  Config,\n  Configs,\n} from '../../types'\n\nconst { each, isBoolean, isObject, last, split, startsWith, trimEnd } = lodash\n\n/**\n * TODO: This function doesn't know how to handle configs with an empty array value (preSelectedNewsletters) and the config will just be ignored\n */\nconst flattenJsonObject = (object: object, initialPathPrefix: string = ``) => {\n\n  function flatten(object, initialPathPrefix) {\n    if (!object || typeof object !== `object`) {\n      return [{ [initialPathPrefix]: object }]\n    }\n\n    const prefix = initialPathPrefix\n      ? Array.isArray(object)\n        ? initialPathPrefix\n        : `${initialPathPrefix}.`\n      : ``\n\n    return Object.keys(object)\n      .flatMap((key) =>\n        flatten(\n          object[key],\n          Array.isArray(object) ? `${prefix}[${key}]` : `${prefix}${key}`,\n        ),\n      )\n      .reduce((acc, path) => ({ ...acc, ...path }), [])\n  }\n\n  const flattenedObject = flatten(object, initialPathPrefix)\n\n  const configs = {}\n  each(flattenedObject, (value, key) => {\n    const splitKey = split(key, `.`)\n    const lastPart = last(splitKey)\n    if (startsWith(lastPart, `#`)) {\n      if (lastPart === `#value`) {\n        configs[trimEnd(key, `.#value`)] = value\n      }\n    } else {\n      configs[key] = value\n    }\n  })\n\n  return configs\n}\n\nconst createConfigsFromJson = (json: object): Configs => {\n\n  const configs = {}\n\n  const flattenJson = flattenJsonObject(json)\n\n  each(flattenJson, (value, key) => {\n\n    let defaultValue = value\n    if (isObject(value)) {\n      defaultValue = value[`#value`]\n    }\n\n    const config: Config = {\n      default: defaultValue,\n    }\n\n    if (isBoolean(defaultValue)) {\n      config.type = `switch`\n    }\n\n    configs[key] = config\n  })\n\n  return configs\n}\n\nexport { createConfigsFromJson }\n","import lodash from 'lodash'\n\nimport type { Configs, NestedConfigs } from '../../types'\nimport { createConfigs } from './createConfigs'\n\nconst { map } = lodash\n\nconst createGroup = (group: string, configs: NestedConfigs): Configs => {\n\n  const groupedConfigs = createConfigs(configs)\n\n  map(groupedConfigs, config => {\n    if (typeof config === `object`) {\n      config.group = group\n    }\n    \n    return config\n  })\n\n  return groupedConfigs\n}\n\nexport { createGroup }\n","import lodash from 'lodash'\n\nimport type { Config, Configs, NestedConfigs } from '../../types'\nimport { createGroup } from './createGroup'\n\nconst { assign, has, isBoolean, isObject, map, mapValues, merge, size } = lodash\n\nconst createFeature = (group: string, enabled: boolean | Config, configs: NestedConfigs = null): Configs => {\n\n  let enabledKey = null\n  \n  const configSize = typeof configs === `object` && size(configs) || -1\n\n  if (configSize !== 1) {\n    throw new Error(`The \"${group}\" group must only have one parent key, ${configSize} given.`)\n  }\n\n  const modifiedConfigs = typeof configs === `object` && mapValues(configs, (config, key) => {\n    if (!enabledKey) {\n\n      let enabledConfig = {\n        type: `switch`,\n        default: enabled,\n      }\n\n      if (isObject(enabled)) {\n        if (!has(enabled, `default`) || !isBoolean(enabled.default)) {\n          throw new Error(`A \"default\" boolean value must be supplied in the object`)\n        }\n\n        merge(enabledConfig, enabled)\n      }\n\n      config = assign({ enabled: enabledConfig }, config)\n      enabledKey = `${key}.enabled`\n    }\n\n    return config\n  })\n\n  let groupedConfigs = createGroup(group, modifiedConfigs)\n\n  map(groupedConfigs, (config, key) => {\n    if (typeof config === `object` && key !== enabledKey) {\n      config.visibleIf = enabledKey\n    }\n\n    return config\n  })\n\n  return groupedConfigs\n}\n\nexport { createFeature }\n","import lodash from 'lodash'\n\nimport type { Configs, NestedConfigs } from '../../types'\nimport { createGroup } from './createGroup'\n\nconst { has, map, mapKeys } = lodash\n\nconst createField = (keyPrefix: string, callback = null): Configs => {\n\n  let fields: Configs = {}\n\n  const visibleIf = `${keyPrefix}.isVisible`\n\n  fields[`isVisible`] = {\n    type: `switch`,\n    label: `Visible`,\n    default: true,\n    group: keyPrefix,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`required`] = {\n    type: `switch`,\n    label: `Required`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`disabled`] = {\n    type: `switch`,\n    label: `Disabled`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`readonly`] = {\n    type: `switch`,\n    label: `Readonly`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`hasAutoFocus`] = {\n    type: `switch`,\n    label: `Autofocus`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`pattern`] = {\n    type: `input`,\n    label: `Pattern`,\n    default: ``,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-12`,\n  }\n\n  if (callback) {\n    fields = callback(fields)\n\n    map(fields, (subField, key) => {\n      if (typeof subField === `object` && !has(subField, `group`)) {\n        subField.group = keyPrefix\n      }\n      \n      if (typeof subField === `object` && key !== `isVisible` && !has(subField, `visibleIf`)) {\n        lodash.set( subField, `visibleIf`, visibleIf )\n      }\n      if (typeof subField === `object` && !has(subField, `styleClasses`)) {\n        subField.styleClasses = `col-md-12`\n      }\n    })\n  }\n\n  const nestedConfigs = mapKeys(fields, (_, key) => {\n    return `${keyPrefix}.${key}`\n  }) as NestedConfigs\n\n  return createGroup(keyPrefix, nestedConfigs)\n}\n\nexport { createField }\n","import lodash from 'lodash'\n\nimport type {\n  ConfigCategory,\n  Configs,\n  Section,\n} from '../../types'\n\nconst { merge } = lodash\n\nconst createSection = (configs: Configs, categoryName: ConfigCategory = null, sectionName: string = null, override: object = null): Section => {\n\n  const section: Section = {\n    configs: {},\n  }\n\n  if (configs) {\n    section.configs = configs\n  }\n\n  if (categoryName) {\n    section.category = categoryName\n  }\n\n  if (sectionName) {\n    section.section = sectionName\n  }\n\n  if (override) {\n    merge(section, override)\n  }\n\n  return section\n}\n\nexport {\n  createSection,\n}\n","import lodash from 'lodash'\n\nimport type {\n  Configs,\n} from '../../types'\n\nconst { mapValues, merge } = lodash\n\nconst createSubSection = (configs: Configs, subsectionName: string): Configs => {\n\n  return mapValues(configs, config => {\n    merge(config, {\n      subsection: subsectionName,\n    })\n\n    return config\n  })\n}\n\nexport {\n  createSubSection,\n}\n","import lodash from 'lodash'\n\nimport type {\n  Configs,\n  Onboarder,\n  OnboarderFields,\n  OnboarderTab,\n} from '../../types'\n\nconst { assign, has, map, mapValues, setWith } = lodash\n\nconst generateModel = schema => {\n\n  const data = {}\n\n  map(schema, tab => {\n    map(tab.fields, field => {\n      setWith(data, field.model, field.default, Object)\n    })\n  })\n\n  return data\n}\n\nconst transformFields = (fields: OnboarderFields, configs: Configs) => {\n\n  return fields.map(field => {\n\n    const key = typeof field === `string` ? field : lodash.get( field, `key` )\n\n    if (has(configs, key)) {\n      const overrides = typeof field === `object` ? field : {}\n      delete overrides.key\n\n      return assign({\n        model: key,\n      }, configs[key], overrides)\n    }\n\n    console.log(`${key} is not a config!`)\n\n    return null\n  }).filter(field => {\n    if (field !== null) {\n      return field\n    }\n  })\n}\n\nconst parseSchema = (onboarder: Onboarder, configs: Configs) => {\n\n  return mapValues(onboarder, (tab, index) => {\n\n    const tabObj: OnboarderTab = {\n      id: index,\n      order: Number(index),\n      label: tab.label,\n      fields: transformFields(tab.fields, configs),\n    }\n\n    return tabObj\n  })\n\n}\n\nconst parseOnboarder = (name: string, onboarder: Onboarder, configs: Configs) => {\n\n  const obj: any = {\n    name: name,\n    schema: [],\n    model: {},\n  }\n\n  if (onboarder) {\n    const schema = parseSchema(onboarder, configs)\n\n    obj.schema = schema\n    obj.model = generateModel(schema)\n  }\n\n  return obj\n}\n\nexport { parseOnboarder }\n","import lodash from 'lodash'\nimport { Components } from 'swagger-jsdoc'\n\nimport type { ComponentOptions, Config, ConfigObject, Configs, Source, StandardizedConfigs } from '../../types'\nimport { convertToNested } from './convertToNested'\n\nexport type SourceConfigs = { \n  getComponents?: () => Promise<Components>, \n  getConfigs?: () => Promise<Configs>, \n  getLabel?: () => string | Promise<string | undefined>, \n  getName?: () => string | Promise<string | undefined>, \n  source?: string\n}\n\nexport type HelperFunctions = ReturnType<typeof getHelpers>\n\nexport type Definitions = {\n  [key: string]: DefinitionComponent\n}\n\n/* eslint-disable no-unused-vars */\nexport type DefinitionComponent = {\n  getConfigs?: (_: HelperFunctions) => Configs\n  getSettings?: (_: HelperFunctions) => Configs\n  getTranslations?: (_: HelperFunctions) => Configs\n  getUI?: (_: HelperFunctions) => Configs\n}\n/* eslint-enable no-unused-vars */\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nconst getType = (config: Config) => {\n  if (typeof config === `object`) {\n     switch (typeof config.default) {\n      case `boolean`:\n        return `switch`\n    }\n  }\n\n  return `input`\n}\n\nconst standardizeConfig = (key: string, config: Config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config as ConfigObject\n}\n\nconst parseConfig = (key: string, config: Config, options: Partial<ConfigObject> = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  } as ConfigObject, config, options) as ConfigObject\n}\n\nconst parseConfigs = (\n  configs: Configs, \n  options: Partial<ConfigObject> = {}, \n  // eslint-disable-next-line no-unused-vars\n  callback?: (key: string, config: Config) => void,\n) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return lodash.get(config, `key`, key)\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    callback && callback(key, config)\n\n    return parseConfig(key, config, options)\n  }) as StandardizedConfigs\n}\n\nconst parseUniqueConfigs = (set: Configs, configs: Configs, options: Partial<ConfigObject>) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set: Configs, configs: Configs, options: Partial<ComponentOptions>) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components: Components, component: string) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs: Configs, callback = null) => {\n\n    const walked: StandardizedConfigs = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name: string, label: string, configs: Configs, type = `group`) => {\n\n    let path: string = groupTypes[type].path\n    let replacement: ComponentOptions = {}\n\n    each(configs, config => {\n      if (typeof config === `object` && config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name: string, configs: Configs) => {\n    return walkConfigs(configs, (key: string, config: Config) => {\n\n      if (typeof config === `object`) {\n        if (config.visibleIf) {\n          config.visibleIf = `${name}.${config.visibleIf}`\n        }\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n      \n    })\n  }\n\n  const addGroup = (\n    name: string, \n    label: string, \n    configs: Configs, \n    nesting = true, \n    type = `group`, \n    /* eslint-disable-next-line no-unused-vars */  \n    callback?: (_: string, _2: Config) => void,\n  ) => {\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key: string, config: ConfigObject) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name: string, label: string, configs: Configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        typeof config === `object` && lodash.set( config, `visibleIf`, `${name}.enabled` )\n      }\n    })\n\n    return configs as StandardizedConfigs\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  type AddFieldCallbackInnerFuncType = (key: string, config: Config ) => void\n\n  const addField = (\n    key: string, \n    // eslint-disable-next-line no-unused-vars\n    callback?: (arg: { insert: AddFieldCallbackInnerFuncType, modify: AddFieldCallbackInnerFuncType }) => void,\n  ) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert: AddFieldCallbackInnerFuncType = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        fields[key] = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n      }\n\n      const modify: AddFieldCallbackInnerFuncType = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback && callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label: string, configs: Configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = (definitions: Definitions) => {\n\n  const configs: Configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options: Partial<ConfigObject> = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key: string, component?: ComponentOptions) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component) as ComponentOptions\n}\n\nconst parseComponents = (components: Components) => {\n  return mapValues(components, (component, key: string) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  }) as Components\n}\n\nconst parseComponentsFromConfigs = (configs: Configs, structure: Components = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: Components = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (typeof config === `object` && has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }: SourceConfigs) => {\n\n  const name = getName ? await getName() : source\n  const label = getLabel ? await getLabel() : startCase(name)\n\n  const options: Source = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const config = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(config, grabComponents)\n    merge(options, {\n      config,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\n// This should be renamed parseSections (assuming we still need it)\n// const parseConfigs = (source: string, sections) => {\n\n//   const configs: Configs = {}\n\n//   const configKeys = []\n\n//   each(sections, (section, sectionKey) => {\n//     each(section.configs, (config: Config, key: string) => {\n\n//       const finalKey = config.key || key\n//       const finalSection = section.section || sectionKey\n//       const finalCategory = section.category || `setting`\n\n//       if (includes(configKeys, finalKey)) {\n//         throw new Error(`Source \"${source}\" has config with duplicate key \"${finalKey}\". No duplicate keys allowed.`)\n//       } else {\n//         configKeys.push(finalKey)\n//       }\n\n//       const configObj = {\n//         default: null,\n//         type: `input`,\n//         label: startCase(last(split(finalKey, `.`))),\n//         reference: finalKey,\n//         section: finalSection,\n//         category: finalCategory,\n//       }\n\n//       config = assign(configObj, config)\n\n//       configs[finalKey] = config\n//     })\n//   })\n\n//   return configs\n// }\n\nconst getMockResponse = (configs, options = null) => {\n\n  options = assign({\n    nested: false,\n  }, options)\n\n  const data = {}\n\n  each(configs, (config, key) => {\n    data[key] = config.default\n  })\n\n  if (options.nested) {\n    return convertToNested(data)\n  }\n\n  return data\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { getMockResponse, parseSource, SourceError }\n"],"names":["each","lodash","setWith","convertToNested","object","nested","value","key","Object","has","createConfigs","obj","dotObj","walk","into","prefix","entries","forEach","_ref","val","Array","isArray","join","isBoolean","isObject","last","split","startsWith","trimEnd","createConfigsFromJson","json","configs","flattenJson","initialPathPrefix","flattenedObject","flatten","keys","flatMap","reduce","acc","path","_extends","splitKey","lastPart","flattenJsonObject","defaultValue","config","default","type","map","createGroup","group","groupedConfigs","assign","mapValues","merge","size","createFeature","enabled","enabledKey","configSize","Error","modifiedConfigs","enabledConfig","visibleIf","mapKeys","createField","keyPrefix","callback","fields","label","styleClasses","subField","set","nestedConfigs","_","createSection","categoryName","sectionName","override","section","category","createSubSection","subsectionName","subsection","transformFields","field","get","overrides","model","console","log","filter","parseOnboarder","name","onboarder","schema","tab","index","id","order","Number","parseSchema","data","generateModel","kebabCase","startCase","unset","getType","standardizeConfig","skipDefaultCheck","parseConfig","options","docLink","docLinkText","hint","parseConfigs","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","toggleable","description","rootKey","parseSource","getComponents","getConfigs","getLabel","getName","source","_temp5","_temp3","_temp2","grabComponents","_temp","Promise","resolve","then","_getConfigs","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","_parseConfigsAndCompo","parseComponents","getSettings","getTranslations","getUI","helpers","groupTypes","walkConfigs","walked","_callback","addGroup","nesting","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","addFeature","addTab","addField","isVisible","required","disabled","readonly","hasAutoFocus","pattern","insert","modify","getHelpers","e","reject","getMockResponse","SourceError","_Error","error","_this","call","this","message"],"mappings":"sBAIA,IAAQA,EAAkBC,EAAlBD,KAAME,EAAYD,EAAZC,QAERC,EAAkB,SAACC,GAEvB,IAAMC,EAAkB,GAMxB,OAJAL,EAAKI,EAAQ,SAACE,EAAOC,GACnBL,EAAQG,EAAQE,EAAKD,EAAOE,UAGvBH,GCVDI,EAAQR,EAARQ,IAEFC,EAAgB,SAACC,GASrB,IAAMC,EAAS,GAGf,OAVA,SAASC,EAAKC,EAAMH,EAAKI,QAAW,IAAXA,IAAAA,EAAS,IAChCP,OAAOQ,QAAQL,GAAKM,QAAQ,SAAeC,GAAA,IAAbX,EAAKY,EAAAA,GAAAA,EACjCD,EAAA,GAAI,iBAAOC,GAAqBC,MAAMC,QAAQF,IAASV,EAAIU,EAAD,WACrDL,EAAK,GAAIC,OAAAA,EAAQR,CAAAA,IAAKe,KAAlB,MAA+BH,EADoCN,EAAKC,EAAMK,EAASJ,GAAAA,OAAAA,EAAQR,CAAAA,OAM5GM,CAAKD,EAAQD,GAENC,k1CCXT,IAAQZ,EAAgEC,EAAhED,KAAMuB,EAA0DtB,EAA1DsB,UAAWC,EAA+CvB,EAA/CuB,SAAUC,EAAqCxB,EAArCwB,KAAMC,EAA+BzB,EAA/ByB,MAAOC,EAAwB1B,EAAxB0B,WAAYC,EAAY3B,EAAZ2B,QA8CtDC,EAAwB,SAACC,GAE7B,IAAMC,EAAU,GAEVC,EA7CkB,SAAC5B,EAAgB6B,YAAAA,IAAAA,EAAkC,IAuB3E,IAAMC,EArBN,SAASC,EAAQ/B,EAAQ6B,GACoB,IAAAf,EAA3C,IAAKd,GAAU,iBAAOA,EACpB,MAAO,EAAI6B,EAAAA,GAAAA,EAAAA,GAAoB7B,MAGjC,IAAMW,EAASkB,EACXb,MAAMC,QAAQjB,GACZ6B,EACGA,EAHuB,IAAA,GAMhC,OAAOzB,OAAO4B,KAAKhC,GAChBiC,QAAQ,SAAC9B,UACR4B,EACE/B,EAAOG,GACPa,MAAMC,QAAQjB,GAAaW,EAAUR,IAAAA,SAAYQ,EAASR,KAG7D+B,OAAO,SAACC,EAAKC,GAAN,OAAAC,EAAA,GAAqBF,EAAQC,IAAS,IAG1BL,CAAQ/B,EAAQ6B,GAElCF,EAAU,GAahB,OAZA/B,EAAKkC,EAAiB,SAAC5B,EAAOC,GAC5B,IAAMmC,EAAWhB,EAAMnB,OACjBoC,EAAWlB,EAAKiB,GAClBf,EAAWgB,EAAD,KACA,WAARA,IACFZ,EAAQH,EAAQrB,EAAD,YAAoBD,GAGrCyB,EAAQxB,GAAOD,IAIZyB,EAOaa,CAAkBd,GAoBtC,OAlBA9B,EAAKgC,EAAa,SAAC1B,EAAOC,GAExB,IAAIsC,EAAevC,EACfkB,EAASlB,KACXuC,EAAevC,EAChB,WAED,IAAMwC,EAAiB,CACrBC,QAASF,GAGPtB,EAAUsB,KACZC,EAAOE,KACR,UAEDjB,EAAQxB,GAAOuC,IAGVf,GCxEDkB,EAAQhD,EAARgD,IAEFC,EAAc,SAACC,EAAepB,GAElC,IAAMqB,EAAiB1C,EAAcqB,GAUrC,OARAkB,EAAIG,EAAgB,SAAAN,GAKlB,uBAJWA,IACTA,EAAOK,MAAQA,GAGVL,IAGFM,GCdDC,EAAkEpD,EAAlEoD,OAAQ5C,EAA0DR,EAA1DQ,IAAKc,EAAqDtB,EAArDsB,UAAWC,EAA0CvB,EAA1CuB,SAAUyB,EAAgChD,EAAhCgD,IAAKK,EAA2BrD,EAA3BqD,UAAWC,EAAgBtD,EAAhBsD,MAAOC,EAASvD,EAATuD,KAE3DC,EAAgB,SAACN,EAAeO,EAA2B3B,QAAAA,IAAAA,IAAAA,EAAyB,MAExF,IAAI4B,EAAa,KAEXC,mBAAoB7B,GAAwByB,EAAKzB,KAAa,EAEpE,GAAmB,IAAf6B,EACF,MAAM,IAAIC,MAAJ,QAAkBV,EAAlB,0CAAiES,EAAjE,WAGR,IAAME,EAAiDR,iBAAxBvB,GAAwBuB,EAAUvB,EAAS,SAACe,EAAQvC,GACjF,IAAKoD,EAAY,CAEf,IAAII,EAAgB,CAClBf,KAAI,SACJD,QAASW,GAGX,GAAIlC,EAASkC,GAAU,CACrB,IAAKjD,EAAIiD,EAAL,aAA6BnC,EAAUmC,EAAD,SACxC,MAAM,IAAIG,MACX,4DAEDN,EAAMQ,EAAeL,GAGvBZ,EAASO,EAAO,CAAEK,QAASK,GAAiBjB,GAC5Ca,EAAgBpD,EACjB,WAED,OAAOuC,IAGLM,EAAiBF,EAAYC,EAAOW,GAUxC,OARAb,EAAIG,EAAgB,SAACN,EAAQvC,GAK3B,MAJkCA,iBAAvBuC,GAAuBvC,IAAQoD,IACxCb,EAAOkB,UAAYL,GAGdb,IAGFM,GC7CD3C,EAAsBR,EAAtBQ,IAAKwC,EAAiBhD,EAAjBgD,IAAKgB,EAAYhE,EAAZgE,QAEZC,EAAc,SAACC,EAAmBC,QAA4B,IAA5BA,IAAAA,EAAW,MAEjD,IAAIC,EAAkB,GAEhBL,EAAeG,eAErBE,EAAA,UAAsB,CACpBrB,KAAI,SACJsB,gBACAvB,SAAS,EACTI,MAAOgB,EACPI,aAAY,YAGdF,EAAA,SAAqB,CACnBrB,KAAI,SACJsB,iBACAvB,SAAS,EACTI,MAAOgB,EACPH,UAAWA,EACXO,aAAY,YAGdF,EAAA,SAAqB,CACnBrB,KAAI,SACJsB,MAAK,WACLvB,SAAS,EACTI,MAAOgB,EACPH,UAAWA,EACXO,aANmB,YASrBF,EAAM,SAAe,CACnBrB,KADmB,SAEnBsB,MAAK,WACLvB,SAAS,EACTI,MAAOgB,EACPH,UAAWA,EACXO,yBAGFF,EAAA,aAAyB,CACvBrB,cACAsB,MAFuB,YAGvBvB,SAAS,EACTI,MAAOgB,EACPH,UAAWA,EACXO,aAAY,YAGdF,EAAA,QAAoB,CAClBrB,aACAsB,MAFkB,UAGlBvB,WACAI,MAAOgB,EACPH,UAAWA,EACXO,0BAGEH,IACFC,EAASD,EAASC,GAElBpB,EAAIoB,EAAQ,SAACG,EAAUjE,GACe,iBAAzBiE,GAA0B/D,EAAI+D,aACvCA,EAASrB,MAAQgB,oBAGRK,GAA4B,cAAHjE,GAAwBE,EAAI+D,EAAhE,cACEvE,EAAOwE,IAAKD,EAAuBR,YAAAA,GAEjC,iBAAOQ,GAA0B/D,EAAI+D,EAAzC,kBACEA,EAASD,aAAT,gBAKN,IAAMG,EAAgBT,EAAQI,EAAQ,SAACM,EAAGpE,GACxC,OAAU4D,EAAa5D,IAAAA,IAGzB,OAAO2C,EAAYiB,EAAWO,IC/ExBnB,EAAUtD,EAAVsD,MAEFqB,EAAgB,SAAC7C,EAAkB8C,EAAqCC,EAA4BC,YAAjEF,IAAAA,EAA+B,WAAsE,IAAhEC,IAAAA,EAAsB,WAAMC,IAAAA,IAAAA,EAAmB,MAE3H,IAAMC,EAAmB,CACvBjD,QAAS,IAmBX,OAhBIA,IACFiD,EAAQjD,QAAUA,GAGhB8C,IACFG,EAAQC,SAAWJ,GAGjBC,IACFE,EAAQA,QAAUF,GAGhBC,GACFxB,EAAMyB,EAASD,GAGVC,GC1BD1B,EAAqBrD,EAArBqD,UAAWC,EAAUtD,EAAVsD,MAEb2B,EAAmB,SAACnD,EAAkBoD,GAE1C,OAAO7B,EAAUvB,EAAS,SAAAe,GAKxB,OAJAS,EAAMT,EAAQ,CACZsC,WAAYD,IAGPrC,KCNHO,EAAyCpD,EAAzCoD,OAAQ5C,EAAiCR,EAAjCQ,IAAKwC,EAA4BhD,EAA5BgD,IAAKK,EAAuBrD,EAAvBqD,UAAWpD,EAAYD,EAAZC,QAe/BmF,EAAkB,SAAChB,EAAyBtC,GAEhD,OAAOsC,EAAOpB,IAAI,SAAAqC,GAEhB,IAAM/E,mBAAa+E,EAAqBA,EAAQrF,EAAOsF,IAAKD,SAE5D,GAAI7E,EAAIsB,EAASxB,GAAM,CACrB,IAAMiF,EAAY,iBAAOF,EAAqBA,EAAQ,GAGtD,cAFOE,EAAUjF,IAEV8C,EAAO,CACZoC,MAAOlF,GACNwB,EAAQxB,GAAMiF,GAKnB,OAFAE,QAAQC,IAAOpF,EAEf,4BACCqF,OAAO,SAAAN,GACR,GAAc,OAAVA,EACF,OAAOA,KAqBPO,EAAiB,SAACC,EAAcC,EAAsBhE,GAE1D,IAAMpB,EAAW,CACfmF,KAAMA,EACNE,OAAQ,GACRP,MAAO,IAGT,GAAIM,EAAW,CACb,IAAMC,EAzBU,SAACD,EAAsBhE,GAEzC,OAAOuB,EAAUyC,EAAW,SAACE,EAAKC,GAShC,MAP6B,CAC3BC,GAAID,EACJE,MAAOC,OAAOH,GACd5B,MAAO2B,EAAI3B,MACXD,OAAQgB,EAAgBY,EAAI5B,OAAQtC,MAiBvBuE,CAAYP,EAAWhE,GAEtCpB,EAAIqF,OAASA,EACbrF,EAAI8E,MAlEc,SAAAO,GAEpB,IAAMO,EAAO,GAQb,OANAtD,EAAI+C,EAAQ,SAAAC,GACVhD,EAAIgD,EAAI5B,OAAQ,SAAAiB,GACdpF,EAAQqG,EAAMjB,EAAMG,MAAOH,EAAK,QAAU9E,YAIvC+F,EAwDOC,CAAcR,GAG5B,OAAOrF,GCnDD0C,EAAqHpD,EAArHoD,OAAQrD,EAA6GC,EAA7GD,KAAMuF,EAAuGtF,EAAvGsF,IAAK9E,EAAkGR,EAAlGQ,IAAKe,EAA6FvB,EAA7FuB,SAAUiF,EAAmFxG,EAAnFwG,UAAWhF,EAAwExB,EAAxEwB,KAAMwC,GAAkEhE,EAAlEgE,QAASX,GAAyDrD,EAAzDqD,UAAWC,GAA8CtD,EAA9CsD,MAAOkB,GAAuCxE,EAAvCwE,IAAKjB,GAAkCvD,EAAlCuD,KAAM9B,GAA4BzB,EAA5ByB,MAAOgF,GAAqBzG,EAArByG,UAAWC,GAAU1G,EAAV0G,MAE7GC,GAAU,SAAC9D,GACf,MAAA,iBAAWA,GAGL,kBAFYA,EAAM,QAElB,SAKP,SAEK+D,GAAoB,SAACtG,EAAauC,EAAgBgE,GAEtD,QAFkF,IAA5BA,IAAAA,GAAmB,GAErEtF,EAASsB,IACX,IAAKgE,IAAqBrG,EAAIqC,EAAD,WAC3B,MAAM,IAAIe,MAAiBtD,WAAAA,EAC5B,wCAEDuC,EAAS,CACPC,QAASD,GAIb,OAAOA,GAGHiE,GAAc,SAACxG,EAAauC,EAAgBkE,GAMhD,QANgDA,IAAAA,IAAAA,EAAiC,WAEjFlE,EAAS+D,GAAkBtG,EAAKuC,IAElBvC,IAEVuC,EAAOmE,QAAS,CAClB,IAAMC,EAAW,uDAA0DpE,EAAOmE,QAAjE,cACjBnE,EAAOqE,KAAOrE,EAAOqE,KAAOD,SAAqBpE,EAAOqE,KAASD,SAC1DpE,EAAOmE,QAGhB,OAAO5D,EAAO,CACZN,QAAS,KACTC,KAAM4D,GAAQ9D,GACdwB,MAAOoC,GAAUjF,EAAKC,GAAMnB,EAAD,OAC3B0E,SAJY,WAKKnC,EAAQkE,IAGvBI,GAAe,SACnBrF,EACAiF,EAEA5C,GAOA,YATA4C,IAAAA,IAAAA,EAAiC,IAKjCjF,EAAUkC,GAAQlC,EAAS,SAACe,EAAgBvC,GAC1C,OAAON,EAAOsF,IAAIzC,EAAevC,MAAAA,KAG5B+C,GAAUvB,EAAS,SAACe,EAAgBvC,GAIzC,OAFA6D,GAAYA,EAAS7D,EAAKuC,GAEnBiE,GAAYxG,EAAKuC,EAAQkE,MAY9BK,GAA6B,SAAC5C,EAAc1C,EAAkBiF,GAClEzD,GAAMkB,EATmB,SAACA,EAAc1C,EAAkBiF,GAC1D,OAAOI,GAAarF,EAASiF,EAAS,SAACzG,GACrC,GAAIE,EAAIgE,EAAKlE,GACX,MAAM,IAAIsD,MAAyBtD,mBAAAA,EACpC,OAKQ+G,CAAmB7C,EAAK1C,EAASiF,KAsRxCO,GAAiB,SAAChH,EAAaiH,GACnC,OAAOnE,EAAO,CACZiB,MAAOoC,GAAUjF,EAAKC,GAAMnB,EAAD,OAC3B6F,MAAO,EACPqB,YAAY,EACZC,YAAa,KACbC,QAAS,MACRH,IA4CCI,GAAAA,SAAW1G,GAAA,IAAY2G,EAAAA,EAAAA,cAAeC,EAAAA,EAAAA,WAAYC,EAAAA,EAAAA,SAAUC,EAAAA,EAAAA,QAASC,EAAAA,EAAAA,OAA2B,IAAA,IAAAC,EAAA,SAE9FpC,GAF8F,SAAAqC,EAG9F7D,GAH8F,SAAA8D,EAU9FC,GAV8F,IAAAC,EAAA,WAAA,GAYhGR,EAZgG,OAAAS,QAAAC,QAahEV,KAAlCW,KAAA,SAAAC,GAAA,IAAM5F,EAASsE,GAAfsB,GACMC,EA/CyB,SAAC5G,EAAkB6G,QAA8B,IAA9BA,IAAAA,EAAwB,IAG5E,IAAMD,EAAyB,GAE3BE,GAAc,EAyBlB,OAvBA7I,EAAK+B,EAAS,SAAAe,GACZ,GAAI,iBAAOA,GAAuBrC,EAAIqC,EAAD,cACnC,IAAKrC,EAAIkI,EAAY7F,EAAO0E,WAAY,CAEtC,IAAIR,EAAU,GACd,GAAIvG,EAAImI,EAAW9F,EAAO0E,WAAY,CACpC,IAAQsB,EAAeF,EAAU9F,EAAO0E,WAAhCsB,WACR9B,EAAU8B,EAAaA,IAAeF,EAAU9F,EAAO0E,WAGzDmB,EAAW7F,EAAO0E,WAAaD,GAAezE,EAAO0E,UAAWR,SAGlE6B,GAAc,IAIdA,GAAerF,GAAKmF,KACtBA,EAAWI,SAAWxB,GAAc,WAAa,CAC/CnB,MAAO,OAIJuC,EAiBcK,CAA2BlG,EAAQuF,GACtD9E,GAAMyD,EAAS,CACblE,OAAAA,EACA6F,WAAAA,MAGF,IAzH+BM,EAE3BlH,EACA4G,EAsHJO,GAvHInH,EAAmB,GACnB4G,EAyDgB,SAACA,GACvB,OAAOrF,GAAUqF,EAAY,SAACnB,EAAWjH,GACvC,IAAQuI,EAAetB,EAAfsB,WAER,OAAOvB,GAAehH,EAAKuI,EAAaA,IAAe,QA7DtCK,CAHcF,EAyH2BZ,GApH5DrI,EAAKiJ,EAAa,SAACzB,EAAWjH,GAE5B,IACEuH,EAIEN,EAJFM,WACAsB,EAGE5B,EAHF4B,YACAC,EAEE7B,EAFF6B,gBACAC,EACE9B,EADF8B,MAGItC,EAAiC,CACrCQ,UAAWjH,GAGPgJ,EAnPS,SAACZ,EAAwBnB,GAE1C,IAAMgC,EAAa,CACjBrG,MAAO,CACLX,KAAI,UAENyD,IAAK,CACHzD,KADG,SAKDiH,EAAc,SAAC1H,EAAkBqC,QAAAA,IAAAA,IAAAA,EAAW,MAEhD,IAAMsF,EAA8B,GAepC,OAbA1J,EAAK+B,EAAS,SAACe,EAAQvC,GAErB,GADAuC,EAAS+D,GAAkBtG,EAAKuC,GAC5BsB,EAAU,CACZ,IAAAuF,EAGIvF,EAAS7D,EAAKuC,GAClB4G,EAFEnJ,EAAAA,KADAuC,EAAAA,YAKF4G,EAAOnJ,GAAOuC,IAIX4G,GAwDHE,EAAW,SACf9D,EACAxB,EACAvC,EACA8H,EACA7G,EAEAoB,GAIA,YAHE,IAJFyF,IAAAA,GAAU,QAIR,IAHF7G,IAAAA,EAGE,SA7DsB,SAAC8C,EAAcxB,EAAevC,EAAkBiB,QAAAA,IAAAA,IAAAA,EAExE,SAAA,IAAIR,EAAegH,EAAWxG,GAAMR,KAChCsH,EAAgC,GAEpC9J,EAAK+B,EAAS,SAAAe,GACZ,GAAkCA,iBAAvBA,GAAuBA,EAAOK,MAAO,CAG9C,IAAM4G,EAAgBjH,EAAOK,MAE7BnD,EAAKwJ,EAAY,SAAAQ,GACf,IAAM7G,EAAQoC,EAAIoD,EAAY,CAACnB,EAAWwC,EAAUxH,KAAMuH,IAC1D,GAAI5G,EAAO,CACTsB,GAAIqF,EAAa,CAACE,EAAUxH,KAAMuH,GAAgB5G,GAClDwD,GAAMgC,EAAY,CAACnB,EAAWwC,EAAUxH,KAAMuH,IAE9C,IAAME,EAAS1E,EAAIoD,EAAY,CAACnB,EAAWwC,EAAUxH,MAAO,IACvC,IAAjBgB,GAAKyG,IACPtD,GAAMgC,EAAY,CAACnB,EAAWwC,EAAUxH,aAYlDiC,GAAIkE,EAAY,CAACnB,EAAWhF,EAAMsD,GAAOzC,EAAO,CAC9CiB,MAAOA,GACNwF,IA6BHI,CAAkBpE,EAAMxB,EAAOvC,EAASiB,GAEjCyG,EAAY1H,EAAS,SAACxB,EAAauC,GAOxC,OANAA,EAAOK,MAAQL,EAAOK,MAAW2C,EAAlB,IAA0BhD,EAAOK,MAAU2C,EAEtD1B,GACFA,EAAS7D,EAAKuC,GAGT,CACLvC,IAAKsJ,EAAa/D,EAAQvF,IAAAA,EAAQA,EAClCuC,OAAAA,MAgHN,MAAO,CACLqH,UAtJgB,SAACrE,EAAc/D,GAC/B,OAAO0H,EAAY1H,EAAS,SAACxB,EAAauC,GAQxC,MANA,iBAAWA,GACLA,EAAOkB,YACTlB,EAAOkB,UAAe8B,EAAQhD,IAAAA,EAAOkB,WAIlC,CACLzD,IAAQuF,EAAL,IAAavF,EAChBuC,OAAAA,MA4IJsH,WA7GiB,SAACtE,EAAcxB,EAAevC,EAAkB2B,EAAiBmG,GAElF,QAFiEnG,IAAAA,IAAAA,GAAU,QAAOmG,IAAAA,IAAAA,GAAU,GAExFpJ,EAAIsB,EAAD,WACL,MAAM,IAAI8B,MAAkBiC,YAAAA,EAC7B,oDAYD,OAVA/D,EAAUsB,EAAO,CACfK,QAASmD,GAA6BnD,UAAAA,IACrC3B,GAEO6H,EAAS9D,EAAMxB,EAAOvC,EAAS8H,EAAvB,QAAyC,SAACtJ,EAAKuC,GAC/D,YAAIvC,GACF,iBAAOuC,GAAuB7C,EAAOwE,IAAK3B,EAAZ,YAAoCgD,EAApC,eAkGlC8D,SAAAA,EACAS,OAXa,SAAC/F,EAAevC,GAE7B,IAAM+D,EAAOW,EAAUnC,GAEvB,OAAOsF,EAAS9D,EAAMxB,EAAOvC,GAAS,EACvC,QAOCuI,SA1Fe,SACf/J,EAEA6D,GAGA,IAAIC,EAAkB,GAEhBL,EAAezD,EAAN,aAmEf,OAjEA8D,EAAOkG,UAAY,CACjBxH,SAAS,EACTuB,MAFiB,UAGjBC,aAAY,YAGdF,EAAOmG,SAAW,CAChBzH,SAAS,EACTuB,MAFgB,WAGhBN,UAAWA,EACXO,aAAY,YAGdF,EAAOoG,SAAW,CAChB1H,SAAS,EACTuB,MAAK,WACLN,UAAWA,EACXO,aAJgB,YAOlBF,EAAOqG,SAAW,CAChB3H,SAAS,EACTuB,MAFgB,WAGhBN,UAAWA,EACXO,aAAY,YAGdF,EAAOsG,aAAe,CACpB5H,SAAS,EACTuB,MAAK,YACLN,UAAWA,EACXO,aAAY,YAGdF,EAAOuG,QAAU,CACf7H,QAAA,GACAuB,MAFe,UAGfN,UAAWA,EACXO,aAAY,aAGVH,GAkBFA,GAAYA,EAAS,CACnByG,OAjB4C,SAACtK,EAAKuC,GAElD,GAAIrC,EAAI4D,EAAQ9D,GACd,MAAM,IAAIsD,MAAetD,SAAAA,EAC1B,oBAED8D,EAAO9D,GAAOwG,GAAYxG,EAAKuC,EAAQ,CACrCkB,UAAWA,EACXO,aAFqC,eAYvCuG,OAN4C,SAACvK,EAAKuC,GAClDS,GAAMc,EAAO9D,GAAMsG,GAAkBtG,EAAKuC,GAAQ,OAS/C8G,EAASrJ,EAAKmG,GAAUnG,GAAM8D,GAAQ,KAqC7B0G,CAAWpC,EAAYpI,GAEnCuH,EACFT,GAA2BtF,EAAS+F,EAAWyB,GAAUvC,IAGrDoC,GACF/B,GAA2BtF,EAASqH,EAAYG,GAAUlG,EAAO2D,EAAS,CACxE/B,SADwE,aAKxEoE,GACFhC,GAA2BtF,EAASsH,EAAgBE,GAAUlG,EAAO2D,EAAS,CAC5E/B,SAD4E,iBAK5EqE,GACFjC,GAA2BtF,EAASuH,EAAMC,GAAUlG,EAAO2D,EAAS,CAClE/B,SADkE,WAOnE,CACLlD,QAAAA,EACA4G,WAAAA,IA4EApF,GAAMyD,EAAS,CACbjF,QAFkBA,EAAAA,QAGlB4G,WAHMA,EAAAA,aApB0F,GAAA,OAAAL,GAAAA,EAAAG,KAAAH,EAAAG,KAAA,WA2BpG,OAAOzB,IAAAA,EAtBP,IAAMA,EAAkB,CACtBlB,KAAAA,EACAxB,MAAAA,GAPkG,OAU7EuD,EAV6EU,QAAAC,QAUvDX,KAVuDY,KAAAL,GAAAA,EAUrC,MAVqC,OAGtFL,EAAiBA,QAAAA,QAAAA,KAHqEU,KAAAN,GAAAA,EAGxDzB,GAAUZ,KADzCkC,OAAAA,QAAAA,QAAAA,EAAgBA,QAAAA,QAAAA,KAFuES,KAAAP,GAAAA,EAE3DD,IAF1B,MAAA+C,GAAA,OAAAzC,QAAA0C,OAAAD,KAoEXE,GAAkB,SAACnJ,EAASiF,QAAkB,IAAlBA,IAAAA,EAAU,MAE1CA,EAAU3D,EAAO,CACfhD,QAAQ,GACP2G,GAEH,IAAMT,EAAO,GAMb,OAJAvG,EAAK+B,EAAS,SAACe,EAAQvC,GACrBgG,EAAKhG,GAAOuC,EACb,UAEGkE,EAAQ3G,OACHF,EAAgBoG,GAGlBA,GAGH4E,gBAEJ,SAAAC,WAAA,SAAAD,EAAYlD,EAAQoD,GAClB,IAAAC,EADuB,OACvBA,EAAAF,EAAAG,KAAAC,KAASH,EAAMI,QAAf,MAA4BxD,EAA5B,cAAAuD,MACK1F,KAFkB,cAAAwF,WAAzBF,KAAAD,2EAAA,gBAFwBtH"}