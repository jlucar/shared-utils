{"version":3,"file":"index.module.mjs","sources":["../src/fetchConfigs/transformationOptions.ts","../src/fetchConfigs/transformToNested.ts","../src/fetchConfigs/transformResponse.ts","../src/fetchConfigs/transformToConfigValues.ts","../src/parseSource/parseSource.ts","../src/parseSource/parseSourceConfigs.ts"],"sourcesContent":["import lodash from 'lodash'\n\nconst { assign, mapValues } = lodash\n\nexport type TransformationOptions = {\n  nested: boolean,\n  categorized: boolean,\n}\n\nconst getTransformationOptions = (options: Partial<TransformationOptions> = {}): TransformationOptions => {\n\n  options = mapValues(options, () => true)\n\n  const opts: TransformationOptions = {\n    nested: false,\n    categorized: false,\n  }\n\n  return assign(opts, options)\n}\n\nexport { getTransformationOptions }\n","import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst transformToNested = object => {\n\n  const transformed = {}\n\n  each(object, (value, key) => {\n    setWith(transformed, key, value, Object)\n  })\n\n  return transformed\n}\n\nexport { transformToNested }\n","import lodash from 'lodash'\n\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, get } = lodash\n\nconst helpTransformResponse = (response, callback = null) => {\n\n  const transformed = {}\n\n  each(response, (value, key) => {\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, value)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    transformed[key] = value\n  })\n\n  return transformed\n}\n\nconst transformResponse = (response, opts = {}, configs = null) => {\n\n  const options = getTransformationOptions(opts)\n\n  const transformed = helpTransformResponse(response, key => {\n\n    if (options.categorized) {\n\n      const config = get(configs, key)\n\n      if (config) {\n        key = `${config.category}.${key}`\n      }\n    }\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(transformed)\n  }\n\n  return transformed\n}\n\nexport { transformResponse }\n","import lodash from 'lodash'\n\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested' \n\nconst { each, has } = lodash\n\nconst transformFromConfigsToResponse = (configs, callback = null) => {\n\n  const response = {}\n\n  each(configs, (config, key) => {\n\n    let value = has(config, `value`) ? config.value : config.default\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, config)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    response[key] = value\n  })\n\n  return response\n}\n\nconst transformToConfigValues = (configs, opts = {}) => {\n\n  const options = getTransformationOptions(opts)\n\n  const response = transformFromConfigsToResponse(configs, (key, config) => {\n\n    key = options.categorized ? `${config.category}.${key}` : key\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(response)\n  }\n\n  return response\n}\n\nexport { transformToConfigValues }\n","import lodash from 'lodash'\n\nimport type { Component, ComponentOptions, Components, Config, ConfigObject, Configs, Source, StandardizedConfigs } from '../types'\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nexport type SourceConfigs = { \n  getComponents?: () => Promise<Components>, \n  getConfigs?: () => Promise<Configs>, \n  getLabel?: () => string | Promise<string | undefined>, \n  getName?: () => string | Promise<string | undefined>, \n  source?: string\n}\n\nexport type HelperFunctions = ReturnType<typeof getHelpers>\n\nexport type Definitions = {\n  [key: string]: DefinitionComponent\n}\n\n/* eslint-disable no-unused-vars */\nexport type DefinitionComponent = {\n  getConfigs?: (_: HelperFunctions) => Configs\n  getSettings?: (_: HelperFunctions) => Configs\n  getTranslations?: (_: HelperFunctions) => Configs\n  getUI?: (_: HelperFunctions) => Configs,\n  getOptions?: () => Component\n}\n\n/* eslint-enable no-unused-vars */\n\nconst getType = (config: Config) => {\n  if (typeof config === `object`) {\n     switch (typeof config.default) {\n      case `boolean`:\n        return `switch`\n    }\n  }\n\n  return `input`\n}\n\nconst standardizeConfig = (key: string, config: Config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config as ConfigObject\n}\n\nconst parseConfig = (key: string, config: Config, options: Partial<ConfigObject> = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  } as ConfigObject, config, options) as ConfigObject\n}\n\nconst parseConfigs = (\n  configs: Configs, \n  options: Partial<ConfigObject> = {}, \n  // eslint-disable-next-line no-unused-vars\n  callback?: (key: string, config: Config) => void,\n) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return lodash.get(config, `key`, key)\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    callback && callback(key, config)\n\n    return parseConfig(key, config, options)\n  }) as StandardizedConfigs\n}\n\nconst parseUniqueConfigs = (set: Configs, configs: Configs, options: Partial<ConfigObject>) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set: Configs, configs: Configs, options: Partial<ComponentOptions>) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components: Components, component: string) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs: Configs, callback = null) => {\n\n    const walked: StandardizedConfigs = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name: string, label: string, configs: Configs, type = `group`) => {\n\n    let path: string = groupTypes[type].path\n    let replacement: ComponentOptions = {}\n\n    each(configs, config => {\n      if (typeof config === `object` && config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name: string, configs: Configs) => {\n    return walkConfigs(configs, (key: string, config: Config) => {\n\n      if (typeof config === `object`) {\n        if (config.visibleIf) {\n          config.visibleIf = `${name}.${config.visibleIf}`\n        }\n\n         config.longLabel = `${startCase(name)} â‡¢ ${config.longLabel ? config.longLabel : (config.label ? config.label : startCase(key))}`\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n      \n    })\n  }\n\n  const addGroup = (\n    name: string, \n    label: string, \n    configs: Configs, \n    nesting = true, \n    type = `group`, \n    /* eslint-disable-next-line no-unused-vars */  \n    callback?: (_: string, _2: Config) => void,\n  ) => {\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key: string, config: ConfigObject) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name: string, label: string, configs: Configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        typeof config === `object` && lodash.set( config, `visibleIf`, `${name}.enabled` )\n      }\n    })\n\n    return configs as StandardizedConfigs\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  type AddFieldCallbackInnerFuncType = (key: string, config: Config ) => void\n\n  const addField = (\n    key: string, \n    // eslint-disable-next-line no-unused-vars\n    callback?: (arg: { insert: AddFieldCallbackInnerFuncType, modify: AddFieldCallbackInnerFuncType }) => void,\n  ) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    const prettyKey = startCase(key)\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      longLabel: `${prettyKey} â‡¢ Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      longLabel: `${prettyKey} â‡¢ Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      longLabel: `${prettyKey} â‡¢ Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      longLabel: `${prettyKey} â‡¢ Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      longLabel: `${prettyKey} â‡¢ Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      longLabel: `${prettyKey} â‡¢ Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert: AddFieldCallbackInnerFuncType = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        const parsedConfig = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n\n        parsedConfig.longLabel = `${prettyKey} â‡¢ ${parsedConfig.label}`\n\n        fields[key] = parsedConfig\n      }\n\n      const modify: AddFieldCallbackInnerFuncType = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback && callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label: string, configs: Configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = (definitions: Definitions) => {\n\n  const configs: Configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options: Partial<ConfigObject> = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key: string, component?: ComponentOptions) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component) as ComponentOptions\n}\n\nconst parseComponents = (components: Components) => {\n  return mapValues(components, (component, key: string) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  }) as Components\n}\n\nconst parseComponentsFromConfigs = (configs: Configs, structure: Components = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: Components = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (typeof config === `object` && has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }: SourceConfigs) => {\n\n  const name = getName ? await getName() : source\n  const label = getLabel ? await getLabel() : startCase(name)\n\n  const options: Source = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const config = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(config, grabComponents)\n    merge(options, {\n      config,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\n// This should be renamed parseSections (assuming we still need it)\n// const parseConfigs = (source: string, sections) => {\n\n//   const configs: Configs = {}\n\n//   const configKeys = []\n\n//   each(sections, (section, sectionKey) => {\n//     each(section.configs, (config: Config, key: string) => {\n\n//       const finalKey = config.key || key\n//       const finalSection = section.section || sectionKey\n//       const finalCategory = section.category || `setting`\n\n//       if (includes(configKeys, finalKey)) {\n//         throw new Error(`Source \"${source}\" has config with duplicate key \"${finalKey}\". No duplicate keys allowed.`)\n//       } else {\n//         configKeys.push(finalKey)\n//       }\n\n//       const configObj = {\n//         default: null,\n//         type: `input`,\n//         label: startCase(last(split(finalKey, `.`))),\n//         reference: finalKey,\n//         section: finalSection,\n//         category: finalCategory,\n//       }\n\n//       config = assign(configObj, config)\n\n//       configs[finalKey] = config\n//     })\n//   })\n\n//   return configs\n// }\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { parseSource, SourceError }\n","import { parseSource, SourceConfigs } from '../parseSource/parseSource'\n\nconst parseSourceConfigs = async (source: string, stack: Omit<SourceConfigs, `source`>) => {\n\n  const parsedSource = await parseSource({\n    source,\n    ...stack,\n  })\n\n  return parsedSource.configs\n}\n\nexport { parseSourceConfigs }\n"],"names":["assign","lodash","mapValues","getTransformationOptions","options","nested","categorized","each","setWith","transformToNested","object","transformed","value","key","Object","get","transformResponse","response","opts","configs","callback","newKey","_callback","newValue","helpTransformResponse","config","category","has","transformToConfigValues","transformFromConfigsToResponse","isObject","kebabCase","last","mapKeys","merge","set","size","split","startCase","unset","getType","standardizeConfig","skipDefaultCheck","Error","default","parseConfig","docLink","docLinkText","hint","type","label","parseConfigs","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","order","toggleable","description","rootKey","parseSource","getComponents","_ref","getConfigs","getLabel","getName","source","name","grabComponents","then","_getConfigs","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","parseConfigsAndComponents","parseComponents","getSettings","getTranslations","getUI","helpers","groupTypes","group","path","tab","walkConfigs","walked","addGroup","nesting","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","visibleIf","longLabel","addFeature","enabled","addTab","addField","fields","prettyKey","isVisible","styleClasses","required","disabled","readonly","hasAutoFocus","pattern","insert","parsedConfig","modify","getHelpers","_parseConfigsAndCompo","_temp","Promise","resolve","_temp2","e","reject","SourceError","_Error","error","_this","call","this","message","parseSourceConfigs","stack","_extends","parsedSource"],"mappings":"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"}