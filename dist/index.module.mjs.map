{"version":3,"file":"index.module.mjs","sources":["../src/convertToNested.ts","../src/createConfigs.ts","../src/createConfigsFromJson.ts","../src/createFeature.ts","../src/createField.ts","../src/createGroup.ts","../src/createSection.ts","../src/createSubSection.ts","../src/parseOnboarder.ts","../src/parseSource.ts"],"sourcesContent":["import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst convertToNested = object => {\n\n  const nested = {}\n\n  each(object, (value, key) => {\n    setWith(nested, key, value, Object)\n  })\n\n  return nested\n}\n\nexport { convertToNested }\n","import type { Configs, NestedConfigs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { has } = lodash\n\nconst createConfigs = (obj: NestedConfigs): Configs => {\n\n  function walk(into, obj, prefix = []) {\n    Object.entries(obj).forEach(([key, val]) => {\n      if (typeof val === `object` && !Array.isArray(val) && !has(val, `default`)) walk(into, val, [...prefix, key]);\n      else into[[...prefix, key].join(`.`)] = val;\n    });\n  }\n\n  const dotObj = {};\n  walk(dotObj, obj);\n\n  return dotObj;\n}\n\nexport { createConfigs }\n","import type {\n  Config,\n  Configs,\n} from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { each, isBoolean, isObject, last, split, startsWith, trimEnd } = lodash\n\n/**\n * TODO: This function doesn't know how to handle configs with an empty array value (preSelectedNewsletters) and the config will just be ignored\n */\nconst flattenJsonObject = (object: object, initialPathPrefix: string = ``) => {\n\n  function flatten(object, initialPathPrefix) {\n    if (!object || typeof object !== `object`) {\n      return [{ [initialPathPrefix]: object }]\n    }\n\n    const prefix = initialPathPrefix\n      ? Array.isArray(object)\n        ? initialPathPrefix\n        : `${initialPathPrefix}.`\n      : ``\n\n    return Object.keys(object)\n      .flatMap((key) =>\n        flatten(\n          object[key],\n          Array.isArray(object) ? `${prefix}[${key}]` : `${prefix}${key}`,\n        ),\n      )\n      .reduce((acc, path) => ({ ...acc, ...path }), [])\n  }\n\n  const flattenedObject = flatten(object, initialPathPrefix)\n\n  const configs = {}\n  each(flattenedObject, (value, key) => {\n    const splitKey = split(key, `.`)\n    const lastPart = last(splitKey)\n    if (startsWith(lastPart, `#`)) {\n      if (lastPart === `#value`) {\n        configs[trimEnd(key, `.#value`)] = value\n      }\n    } else {\n      configs[key] = value\n    }\n  })\n\n  return configs\n}\n\nconst createConfigsFromJson = (json: object): Configs => {\n\n  const configs = {}\n\n  const flattenJson = flattenJsonObject(json)\n\n  each(flattenJson, (value, key) => {\n\n    let defaultValue = value\n    if (isObject(value)) {\n      defaultValue = value[`#value`]\n    }\n\n    const config: Config = {\n      default: defaultValue,\n    }\n\n    if (isBoolean(defaultValue)) {\n      config.type = `switch`\n    }\n\n    configs[key] = config\n  })\n\n  return configs\n}\n\nexport { createConfigsFromJson }\n","import type { Config, Configs, NestedConfigs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nimport { createGroup } from '.'\n\nconst { assign, has, isBoolean, isObject, map, mapValues, merge, size } = lodash\n\nconst createFeature = (group: string, enabled: boolean | Config, configs: NestedConfigs = null): Configs => {\n\n  let enabledKey = null\n\n  const configSize = size(configs)\n\n  if (configSize !== 1) {\n    throw new Error(`The \"${group}\" group must only have one parent key, ${configSize} given.`)\n  }\n\n  const modifiedConfigs = mapValues(configs, (config, key) => {\n    if (!enabledKey) {\n\n      let enabledConfig = {\n        type: `switch`,\n        default: enabled,\n      }\n\n      if (isObject(enabled)) {\n        if (!has(enabled, `default`) || !isBoolean(enabled.default)) {\n          throw new Error(`A \"default\" boolean value must be supplied in the object`)\n        }\n\n        merge(enabledConfig, enabled)\n      }\n\n      config = assign({ enabled: enabledConfig }, config)\n      enabledKey = `${key}.enabled`\n    }\n\n    return config\n  })\n\n  let groupedConfigs = createGroup(group, modifiedConfigs)\n\n  map(groupedConfigs, (config, key) => {\n    if (key !== enabledKey) {\n      config.visibleIf = enabledKey\n    }\n\n    return config\n  })\n\n  return groupedConfigs\n}\n\nexport { createFeature }\n","import type { Configs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nimport { createGroup } from '.'\n\nconst { has, map, mapKeys } = lodash\n\nconst createField = (keyPrefix: string, callback = null): Configs => {\n\n  let fields: Configs = {}\n\n  const visibleIf = `${keyPrefix}.isVisible`\n\n  fields[`isVisible`] = {\n    type: `switch`,\n    label: `Visible`,\n    default: true,\n    group: keyPrefix,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`required`] = {\n    type: `switch`,\n    label: `Required`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`disabled`] = {\n    type: `switch`,\n    label: `Disabled`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`readonly`] = {\n    type: `switch`,\n    label: `Readonly`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`hasAutoFocus`] = {\n    type: `switch`,\n    label: `Autofocus`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`pattern`] = {\n    type: `input`,\n    label: `Pattern`,\n    default: ``,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-12`,\n  }\n\n  if (callback) {\n    fields = callback(fields)\n\n    map(fields, (subField, key) => {\n      if (!has(subField, `group`)) {\n        subField.group = keyPrefix\n      }\n      if (key !== `isVisible` && !has(subField, `visibleIf`)) {\n        subField.visibleIf = visibleIf\n      }\n      if (!has(subField, `styleClasses`)) {\n        subField.styleClasses = `col-md-12`\n      }\n    })\n  }\n\n  return createGroup(keyPrefix, mapKeys(fields, (subField, key) => {\n    return `${keyPrefix}.${key}`\n  }))\n}\n\nexport { createField }\n","import type { Configs, NestedConfigs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nimport { createConfigs } from '.'\n\nconst { map } = lodash\n\nconst createGroup = (group: string, configs: NestedConfigs): Configs => {\n\n  const groupedConfigs = createConfigs(configs)\n\n  map(groupedConfigs, config => {\n    config.group = group\n\n    return config\n  })\n\n  return groupedConfigs\n}\n\nexport { createGroup }\n","import type {\n  ConfigCategory,\n  Configs,\n  Section,\n} from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { merge } = lodash\n\nconst createSection = (configs: Configs, categoryName: ConfigCategory = null, sectionName: string = null, override: object = null): Section => {\n\n  const section: Section = {\n    configs: {},\n  }\n\n  if (configs) {\n    section.configs = configs\n  }\n\n  if (categoryName) {\n    section.category = categoryName\n  }\n\n  if (sectionName) {\n    section.section = sectionName\n  }\n\n  if (override) {\n    merge(section, override)\n  }\n\n  return section\n}\n\nexport {\n  createSection,\n}\n","import type {\n  Configs,\n} from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { mapValues, merge } = lodash\n\nconst createSubSection = (configs: Configs, subsectionName: string): Configs => {\n\n  return mapValues(configs, config => {\n    merge(config, {\n      subsection: subsectionName,\n    })\n\n    return config\n  })\n}\n\nexport {\n  createSubSection,\n}\n","import type {\n  Configs,\n  Onboarder,\n  OnboarderFields,\n  OnboarderTab,\n} from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { assign, has, map, mapValues, setWith } = lodash\n\nconst generateModel = schema => {\n\n  const data = {}\n\n  map(schema, tab => {\n    map(tab.fields, field => {\n      setWith(data, field.model, field.default, Object)\n    })\n  })\n\n  return data\n}\n\nconst transformFields = (fields: OnboarderFields, configs: Configs) => {\n\n  return fields.map(field => {\n\n    const key = typeof field === `string` ? field : field.key\n\n    if (has(configs, key)) {\n      const overrides = typeof field === `object` ? field : {}\n      delete overrides.key\n\n      return assign({\n        model: key,\n      }, configs[key], overrides)\n    }\n\n    console.log(`${key} is not a config!`)\n\n    return null\n  }).filter(field => {\n    if (field !== null) {\n      return field\n    }\n  })\n}\n\nconst parseSchema = (onboarder: Onboarder, configs: Configs) => {\n\n  return mapValues(onboarder, (tab, index) => {\n\n    const tabObj: OnboarderTab = {\n      id: index,\n      order: Number(index),\n      label: tab.label,\n      fields: transformFields(tab.fields, configs),\n    }\n\n    return tabObj\n  })\n\n}\n\nconst parseOnboarder = (name: string, onboarder: Onboarder, configs: Configs) => {\n\n  const obj: any = {\n    name: name,\n    schema: [],\n    model: {},\n  }\n\n  if (onboarder) {\n    const schema = parseSchema(onboarder, configs)\n\n    obj.schema = schema\n    obj.model = generateModel(schema)\n  }\n\n  return obj\n}\n\nexport { parseOnboarder }\n","import type { Config, Configs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nimport { convertToNested } from '.'\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nconst getType = (config) => {\n  switch (typeof config.default) {\n    case `boolean`:\n      return `switch`\n    default:\n      return `input`\n  }\n}\n\nconst standardizeConfig = (key, config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config\n}\n\nconst parseConfig = (key, config, options = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  }, config, options)\n}\n\nconst parseConfigs = (configs: Configs, options = {}, callback = null) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return config.key ? config.key : key\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    if (callback) {\n      callback(key, config)\n    }\n\n    return parseConfig(key, config, options)\n  })\n}\n\nconst parseUniqueConfigs = (set, configs, options) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set, configs, options) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components, component) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs, callback = null) => {\n\n    const walked = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name, label, configs, type = `group`) => {\n\n    let path = groupTypes[type].path\n    let replacement = {}\n\n    each(configs, config => {\n      if (config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name, configs) => {\n    return walkConfigs(configs, (key, config) => {\n\n      if (config.visibleIf) {\n        config.visibleIf = `${name}.${config.visibleIf}`\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n    })\n  }\n\n  const addGroup = (name, label, configs, nesting = true, type = `group`, callback = null) => {\n\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key, config) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name, label, configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        config.visibleIf = `${name}.enabled`\n      }\n    })\n\n    return configs\n  }\n\n  const addField = (key, callback = null) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        fields[key] = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n      }\n\n      const modify = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label, configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = definitions => {\n\n  const configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key, component = null) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component)\n}\n\nconst parseComponents = components => {\n  return mapValues(components, (component, key) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  })\n}\n\nconst parseComponentsFromConfigs = (configs, structure = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: { [key: string]: object } = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }: { getComponents?: any, getConfigs?: any, getLabel?: any, getName?: any, source?: string}) => {\n\n  const name = getName ? getName() : source\n  const label = getLabel ? getLabel() : startCase(name)\n\n  const options: {\n    name: any,\n    label: any,\n    configs?: any,\n    components?: any\n  } = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const configs = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(configs, grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\n// This should be renamed parseSections (assuming we still need it)\n// const parseConfigs = (source: string, sections) => {\n\n//   const configs: Configs = {}\n\n//   const configKeys = []\n\n//   each(sections, (section, sectionKey) => {\n//     each(section.configs, (config: Config, key: string) => {\n\n//       const finalKey = config.key || key\n//       const finalSection = section.section || sectionKey\n//       const finalCategory = section.category || `setting`\n\n//       if (includes(configKeys, finalKey)) {\n//         throw new Error(`Source \"${source}\" has config with duplicate key \"${finalKey}\". No duplicate keys allowed.`)\n//       } else {\n//         configKeys.push(finalKey)\n//       }\n\n//       const configObj = {\n//         default: null,\n//         type: `input`,\n//         label: startCase(last(split(finalKey, `.`))),\n//         reference: finalKey,\n//         section: finalSection,\n//         category: finalCategory,\n//       }\n\n//       config = assign(configObj, config)\n\n//       configs[finalKey] = config\n//     })\n//   })\n\n//   return configs\n// }\n\nconst getMockResponse = (configs, options = null) => {\n\n  options = assign({\n    nested: false,\n  }, options)\n\n  const data = {}\n\n  each(configs, (config, key) => {\n    data[key] = config.default\n  })\n\n  if (options.nested) {\n    return convertToNested(data)\n  }\n\n  return data\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { getMockResponse, parseSource, SourceError }\n"],"names":["each","lodash","setWith","convertToNested","object","nested","value","key","Object","has","createConfigs","obj","dotObj","walk","into","prefix","entries","forEach","_ref","val","Array","isArray","join","isBoolean","isObject","last","split","startsWith","trimEnd","createConfigsFromJson","json","configs","flattenJson","initialPathPrefix","flattenedObject","flatten","keys","flatMap","reduce","acc","path","_extends","splitKey","lastPart","flattenJsonObject","defaultValue","config","default","type","assign","map","mapValues","merge","size","createFeature","group","enabled","enabledKey","configSize","Error","modifiedConfigs","enabledConfig","groupedConfigs","createGroup","visibleIf","mapKeys","createField","keyPrefix","callback","fields","label","styleClasses","subField","createSection","categoryName","sectionName","override","section","category","createSubSection","subsectionName","subsection","transformFields","field","overrides","model","console","log","filter","parseOnboarder","name","onboarder","schema","tab","index","id","order","Number","parseSchema","data","generateModel","get","kebabCase","set","startCase","unset","getType","standardizeConfig","skipDefaultCheck","parseConfig","options","docLink","docLinkText","hint","parseConfigs","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","toggleable","description","rootKey","parseSource","getComponents","getConfigs","getLabel","getName","source","grabComponents","then","_getConfigs","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","parseConfigsAndComponents","parseComponents","getSettings","getTranslations","getUI","helpers","groupTypes","walkConfigs","walked","_callback","addGroup","nesting","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","addFeature","addTab","addField","isVisible","required","disabled","readonly","hasAutoFocus","pattern","insert","modify","getHelpers","_parseConfigsAndCompo","_temp","Promise","resolve","_temp3","e","reject","getMockResponse","SourceError","_Error","error","_this","call","this","message"],"mappings":"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"}