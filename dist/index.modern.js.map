{"version":3,"file":"index.modern.js","sources":["../src/fetchConfigs/transformationOptions.ts","../src/fetchConfigs/transformResponse.ts","../src/fetchConfigs/transformToConfigValues.ts","../src/fetchConfigs/transformToNested.ts","../src/parseSource/parseSource.ts","../src/parseSource/parseSourceConfigs.ts"],"sourcesContent":["import lodash from 'lodash'\n\nconst { assign, mapValues } = lodash\n\nexport type TransformationOptions = {\n  nested: boolean,\n  categorized: boolean,\n}\n\nconst getTransformationOptions = (options: Partial<TransformationOptions> = {}): TransformationOptions => {\n\n  options = mapValues(options, () => true)\n\n  const opts: TransformationOptions = {\n    nested: false,\n    categorized: false,\n  }\n\n  return assign(opts, options)\n}\n\nexport { getTransformationOptions }\n","import lodash from 'lodash'\n\nimport { getTransformationOptions, transformToNested } from '.'\n\nconst { each, get } = lodash\n\nconst helpTransformResponse = (response, callback = null) => {\n\n  const transformed = {}\n\n  each(response, (value, key) => {\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, value)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    transformed[key] = value\n  })\n\n  return transformed\n}\n\nconst transformResponse = (response, opts = {}, configs = null) => {\n\n  const options = getTransformationOptions(opts)\n\n  const transformed = helpTransformResponse(response, key => {\n\n    if (options.categorized) {\n\n      const config = get(configs, key)\n\n      if (config) {\n        key = `${config.category}.${key}`\n      }\n    }\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(transformed)\n  }\n\n  return transformed\n}\n\nexport { transformResponse }\n","import lodash from 'lodash'\n\nimport { getTransformationOptions, transformToNested } from '.'\n\nconst { each, has } = lodash\n\nconst transformFromConfigsToResponse = (configs, callback = null) => {\n\n  const response = {}\n\n  each(configs, (config, key) => {\n\n    let value = has(config, `value`) ? config.value : config.default\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, config)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    response[key] = value\n  })\n\n  return response\n}\n\nconst transformToConfigValues = (configs, opts = {}) => {\n\n  const options = getTransformationOptions(opts)\n\n  const response = transformFromConfigsToResponse(configs, (key, config) => {\n\n    key = options.categorized ? `${config.category}.${key}` : key\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(response)\n  }\n\n  return response\n}\n\nexport { transformToConfigValues }\n","import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst transformToNested = object => {\n\n  const transformed = {}\n\n  each(object, (value, key) => {\n    setWith(transformed, key, value, Object)\n  })\n\n  return transformed\n}\n\nexport { transformToNested }\n","import type { Config, Configs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nconst getType = (config) => {\n  switch (typeof config.default) {\n    case `boolean`:\n      return `switch`\n    default:\n      return `input`\n  }\n}\n\nconst standardizeConfig = (key, config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config\n}\n\nconst parseConfig = (key, config, options = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  }, config, options)\n}\n\nconst parseConfigs = (configs: Configs, options = {}, callback = null) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return config[`key`] ? config[`key`] : key\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    if (callback) {\n      callback(key, config)\n    }\n\n    return parseConfig(key, config, options)\n  })\n}\n\nconst parseUniqueConfigs = (set, configs, options) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set, configs, options) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components, component) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs, callback = null) => {\n\n    const walked = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name, label, configs, type = `group`) => {\n\n    let path = groupTypes[type].path\n    let replacement = {}\n\n    each(configs, config => {\n      if (config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name, configs) => {\n    return walkConfigs(configs, (key, config) => {\n\n      if (config.visibleIf) {\n        config.visibleIf = `${name}.${config.visibleIf}`\n      }\n\n      config.longLabel = `${startCase(name)} ⇢ ${config.longLabel ? config.longLabel : (config.label ? config.label : startCase(key))}`\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n    })\n  }\n\n  const addGroup = (name, label, configs, nesting = true, type = `group`, callback = null) => {\n\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key, config) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name, label, configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        config.visibleIf = `${name}.enabled`\n      }\n    })\n\n    return configs\n  }\n\n  const addField = (key, callback = null) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    const prettyKey = startCase(key)\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      longLabel: `${prettyKey} ⇢ Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      longLabel: `${prettyKey} ⇢ Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      longLabel: `${prettyKey} ⇢ Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      longLabel: `${prettyKey} ⇢ Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      longLabel: `${prettyKey} ⇢ Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      longLabel: `${prettyKey} ⇢ Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        const parsedConfig = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n\n        parsedConfig.longLabel = `${prettyKey} ⇢ ${parsedConfig.label}`\n\n        fields[key] = parsedConfig\n      }\n\n      const modify = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label, configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = definitions => {\n\n  const configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key, component = null) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component)\n}\n\nconst parseComponents = components => {\n  return mapValues(components, (component, key) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  })\n}\n\nconst parseComponentsFromConfigs = (configs, structure = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: { [key: string]: object } = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }: { getComponents?: any, getConfigs?: any, getLabel?: any, getName?: any, source?: string }) => {\n\n  const name = getName ? getName() : source\n  const label = getLabel ? getLabel() : startCase(name)\n\n  const options: {\n    name: any,\n    label: any,\n    configs?: any,\n    components?: any\n  } = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const configs = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(configs, grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\n// This should be renamed parseSections (assuming we still need it)\n// const parseConfigs = (source: string, sections) => {\n\n//   const configs: Configs = {}\n\n//   const configKeys = []\n\n//   each(sections, (section, sectionKey) => {\n//     each(section.configs, (config: Config, key: string) => {\n\n//       const finalKey = config.key || key\n//       const finalSection = section.section || sectionKey\n//       const finalCategory = section.category || `setting`\n\n//       if (includes(configKeys, finalKey)) {\n//         throw new Error(`Source \"${source}\" has config with duplicate key \"${finalKey}\". No duplicate keys allowed.`)\n//       } else {\n//         configKeys.push(finalKey)\n//       }\n\n//       const configObj = {\n//         default: null,\n//         type: `input`,\n//         label: startCase(last(split(finalKey, `.`))),\n//         reference: finalKey,\n//         section: finalSection,\n//         category: finalCategory,\n//       }\n\n//       config = assign(configObj, config)\n\n//       configs[finalKey] = config\n//     })\n//   })\n\n//   return configs\n// }\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { parseSource, SourceError }\n","import { parseSource } from '../'\n\nconst parseSourceConfigs = async (source: string, stack) => {\n\n  const parsedSource = await parseSource({\n    source,\n    ...stack,\n  })\n\n  return parsedSource.configs\n}\n\nexport { parseSourceConfigs }\n"],"names":["assign","mapValues","lodash","getTransformationOptions","options","nested","categorized","each","get","transformResponse","response","opts","configs","transformed","callback","value","key","newKey","newValue","helpTransformResponse","config","category","transformToNested","has","transformToConfigValues","default","transformFromConfigsToResponse","setWith","object","Object","isObject","kebabCase","last","mapKeys","merge","set","size","split","startCase","unset","getType","standardizeConfig","skipDefaultCheck","Error","parseConfig","docLink","docLinkText","hint","type","label","parseConfigs","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","order","toggleable","description","rootKey","parseSource","async","getComponents","getConfigs","getLabel","getName","source","name","grabComponents","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","parseComponents","getSettings","getTranslations","getUI","helpers","groupTypes","group","path","tab","walkConfigs","walked","newConfig","addGroup","nesting","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","visibleIf","longLabel","addFeature","enabled","addTab","addField","fields","prettyKey","isVisible","styleClasses","required","disabled","readonly","hasAutoFocus","pattern","insert","parsedConfig","modify","getHelpers","parseConfigsAndComponents","SourceError","constructor","error","super","message","this","parseSourceConfigs","stack","_extends"],"mappings":"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"}