{"version":3,"file":"index.modern.js","sources":["../src/convertToNested.ts","../src/createConfigs.ts","../src/createConfigsFromJson.ts","../src/createGroup.ts","../src/createFeature.ts","../src/createField.ts","../src/createSection.ts","../src/createSubSection.ts","../src/parseOnboarder.ts","../src/parseSource.ts"],"sourcesContent":["import lodash from 'lodash'\n\nimport { Configs } from '../../types'\n\nconst { each, setWith } = lodash\n\nconst convertToNested = (object: Configs) => {\n\n  const nested: Configs = {}\n\n  each(object, (value, key) => {\n    setWith(nested, key, value, Object)\n  })\n\n  return nested\n}\n\nexport { convertToNested }\n","import lodash from 'lodash'\n\nimport type { Configs, NestedConfigs } from '../../types'\n\nconst { has } = lodash\n\nconst createConfigs = (obj: NestedConfigs): Configs => {\n\n  function walk(into, obj, prefix = []) {\n    Object.entries(obj).forEach(([key, val]) => {\n      if (typeof val === `object` && !Array.isArray(val) && !has(val, `default`)) walk(into, val, [...prefix, key]);\n      else into[[...prefix, key].join(`.`)] = val;\n    });\n  }\n\n  const dotObj = {};\n  walk(dotObj, obj);\n\n  return dotObj;\n}\n\nexport { createConfigs }\n","import lodash from 'lodash'\n\nimport type {\n  Config,\n  Configs,\n} from '../../types'\n\nconst { each, isBoolean, isObject, last, split, startsWith, trimEnd } = lodash\n\n/**\n * TODO: This function doesn't know how to handle configs with an empty array value (preSelectedNewsletters) and the config will just be ignored\n */\nconst flattenJsonObject = (object: object, initialPathPrefix: string = ``) => {\n\n  function flatten(object, initialPathPrefix) {\n    if (!object || typeof object !== `object`) {\n      return [{ [initialPathPrefix]: object }]\n    }\n\n    const prefix = initialPathPrefix\n      ? Array.isArray(object)\n        ? initialPathPrefix\n        : `${initialPathPrefix}.`\n      : ``\n\n    return Object.keys(object)\n      .flatMap((key) =>\n        flatten(\n          object[key],\n          Array.isArray(object) ? `${prefix}[${key}]` : `${prefix}${key}`,\n        ),\n      )\n      .reduce((acc, path) => ({ ...acc, ...path }), [])\n  }\n\n  const flattenedObject = flatten(object, initialPathPrefix)\n\n  const configs = {}\n  each(flattenedObject, (value, key) => {\n    const splitKey = split(key, `.`)\n    const lastPart = last(splitKey)\n    if (startsWith(lastPart, `#`)) {\n      if (lastPart === `#value`) {\n        configs[trimEnd(key, `.#value`)] = value\n      }\n    } else {\n      configs[key] = value\n    }\n  })\n\n  return configs\n}\n\nconst createConfigsFromJson = (json: object): Configs => {\n\n  const configs = {}\n\n  const flattenJson = flattenJsonObject(json)\n\n  each(flattenJson, (value, key) => {\n\n    let defaultValue = value\n    if (isObject(value)) {\n      defaultValue = value[`#value`]\n    }\n\n    const config: Config = {\n      default: defaultValue,\n    }\n\n    if (isBoolean(defaultValue)) {\n      config.type = `switch`\n    }\n\n    configs[key] = config\n  })\n\n  return configs\n}\n\nexport { createConfigsFromJson }\n","import lodash from 'lodash'\n\nimport type { Configs, NestedConfigs } from '../../types'\nimport { createConfigs } from './createConfigs'\n\nconst { map } = lodash\n\nconst createGroup = (group: string, configs: NestedConfigs): Configs => {\n\n  const groupedConfigs = createConfigs(configs)\n\n  map(groupedConfigs, config => {\n    if (typeof config === `object`) {\n      config.group = group\n    }\n    \n    return config\n  })\n\n  return groupedConfigs\n}\n\nexport { createGroup }\n","import lodash from 'lodash'\n\nimport type { Config, Configs, NestedConfigs } from '../../types'\nimport { createGroup } from './createGroup'\n\nconst { assign, has, isBoolean, isObject, map, mapValues, merge, size } = lodash\n\nconst createFeature = (group: string, enabled: boolean | Config, configs: NestedConfigs = null): Configs => {\n\n  let enabledKey = null\n  \n  const configSize = typeof configs === `object` && size(configs) || -1\n\n  if (configSize !== 1) {\n    throw new Error(`The \"${group}\" group must only have one parent key, ${configSize} given.`)\n  }\n\n  const modifiedConfigs = typeof configs === `object` && mapValues(configs, (config, key) => {\n    if (!enabledKey) {\n\n      let enabledConfig = {\n        type: `switch`,\n        default: enabled,\n      }\n\n      if (isObject(enabled)) {\n        if (!has(enabled, `default`) || !isBoolean(enabled.default)) {\n          throw new Error(`A \"default\" boolean value must be supplied in the object`)\n        }\n\n        merge(enabledConfig, enabled)\n      }\n\n      config = assign({ enabled: enabledConfig }, config)\n      enabledKey = `${key}.enabled`\n    }\n\n    return config\n  })\n\n  let groupedConfigs = createGroup(group, modifiedConfigs)\n\n  map(groupedConfigs, (config, key) => {\n    if (typeof config === `object` && key !== enabledKey) {\n      config.visibleIf = enabledKey\n    }\n\n    return config\n  })\n\n  return groupedConfigs\n}\n\nexport { createFeature }\n","import lodash from 'lodash'\n\nimport type { Configs, NestedConfigs } from '../../types'\nimport { createGroup } from './createGroup'\n\nconst { has, map, mapKeys } = lodash\n\nconst createField = (keyPrefix: string, callback = null): Configs => {\n\n  let fields: Configs = {}\n\n  const visibleIf = `${keyPrefix}.isVisible`\n\n  fields[`isVisible`] = {\n    type: `switch`,\n    label: `Visible`,\n    default: true,\n    group: keyPrefix,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`required`] = {\n    type: `switch`,\n    label: `Required`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`disabled`] = {\n    type: `switch`,\n    label: `Disabled`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`readonly`] = {\n    type: `switch`,\n    label: `Readonly`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`hasAutoFocus`] = {\n    type: `switch`,\n    label: `Autofocus`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`pattern`] = {\n    type: `input`,\n    label: `Pattern`,\n    default: ``,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-12`,\n  }\n\n  if (callback) {\n    fields = callback(fields)\n\n    map(fields, (subField, key) => {\n      if (typeof subField === `object` && !has(subField, `group`)) {\n        subField.group = keyPrefix\n      }\n      \n      if (typeof subField === `object` && key !== `isVisible` && !has(subField, `visibleIf`)) {\n        lodash.set( subField, `visibleIf`, visibleIf )\n      }\n      if (typeof subField === `object` && !has(subField, `styleClasses`)) {\n        subField.styleClasses = `col-md-12`\n      }\n    })\n  }\n\n  const nestedConfigs = mapKeys(fields, (_, key) => {\n    return `${keyPrefix}.${key}`\n  }) as NestedConfigs\n\n  return createGroup(keyPrefix, nestedConfigs)\n}\n\nexport { createField }\n","import lodash from 'lodash'\n\nimport type {\n  ConfigCategory,\n  Configs,\n  Section,\n} from '../../types'\n\nconst { merge } = lodash\n\nconst createSection = (configs: Configs, categoryName: ConfigCategory = null, sectionName: string = null, override: object = null): Section => {\n\n  const section: Section = {\n    configs: {},\n  }\n\n  if (configs) {\n    section.configs = configs\n  }\n\n  if (categoryName) {\n    section.category = categoryName\n  }\n\n  if (sectionName) {\n    section.section = sectionName\n  }\n\n  if (override) {\n    merge(section, override)\n  }\n\n  return section\n}\n\nexport {\n  createSection,\n}\n","import lodash from 'lodash'\n\nimport type {\n  Configs,\n} from '../../types'\n\nconst { mapValues, merge } = lodash\n\nconst createSubSection = (configs: Configs, subsectionName: string): Configs => {\n\n  return mapValues(configs, config => {\n    merge(config, {\n      subsection: subsectionName,\n    })\n\n    return config\n  })\n}\n\nexport {\n  createSubSection,\n}\n","import lodash from 'lodash'\n\nimport type {\n  Configs,\n  Onboarder,\n  OnboarderFields,\n  OnboarderTab,\n} from '../../types'\n\nconst { assign, has, map, mapValues, setWith } = lodash\n\nconst generateModel = schema => {\n\n  const data = {}\n\n  map(schema, tab => {\n    map(tab.fields, field => {\n      setWith(data, field.model, field.default, Object)\n    })\n  })\n\n  return data\n}\n\nconst transformFields = (fields: OnboarderFields, configs: Configs) => {\n\n  return fields.map(field => {\n\n    const key = typeof field === `string` ? field : lodash.get( field, `key` )\n\n    if (has(configs, key)) {\n      const overrides = typeof field === `object` ? field : {}\n      delete overrides.key\n\n      return assign({\n        model: key,\n      }, configs[key], overrides)\n    }\n\n    console.log(`${key} is not a config!`)\n\n    return null\n  }).filter(field => {\n    if (field !== null) {\n      return field\n    }\n  })\n}\n\nconst parseSchema = (onboarder: Onboarder, configs: Configs) => {\n\n  return mapValues(onboarder, (tab, index) => {\n\n    const tabObj: OnboarderTab = {\n      id: index,\n      order: Number(index),\n      label: tab.label,\n      fields: transformFields(tab.fields, configs),\n    }\n\n    return tabObj\n  })\n\n}\n\nconst parseOnboarder = (name: string, onboarder: Onboarder, configs: Configs) => {\n\n  const obj: any = {\n    name: name,\n    schema: [],\n    model: {},\n  }\n\n  if (onboarder) {\n    const schema = parseSchema(onboarder, configs)\n\n    obj.schema = schema\n    obj.model = generateModel(schema)\n  }\n\n  return obj\n}\n\nexport { parseOnboarder }\n","import lodash from 'lodash'\nimport { Components } from 'swagger-jsdoc'\n\nimport type { ComponentOptions, Config, ConfigObject, Configs, Source, StandardizedConfigs } from '../../types'\nimport { convertToNested } from './convertToNested'\n\nexport type SourceConfigs = { \n  getComponents?: () => Promise<Components>, \n  getConfigs?: () => Promise<Configs>, \n  getLabel?: () => string | Promise<string | undefined>, \n  getName?: () => string | Promise<string | undefined>, \n  source?: string\n}\n\nexport type HelperFunctions = ReturnType<typeof getHelpers>\n\nexport type Definitions = {\n  [key: string]: DefinitionComponent\n}\n\n/* eslint-disable no-unused-vars */\nexport type DefinitionComponent = {\n  getConfigs?: (_: HelperFunctions) => Configs\n  getSettings?: (_: HelperFunctions) => Configs\n  getTranslations?: (_: HelperFunctions) => Configs\n  getUI?: (_: HelperFunctions) => Configs\n}\n/* eslint-enable no-unused-vars */\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nconst getType = (config: Config) => {\n  if (typeof config === `object`) {\n     switch (typeof config.default) {\n      case `boolean`:\n        return `switch`\n    }\n  }\n\n  return `input`\n}\n\nconst standardizeConfig = (key: string, config: Config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config as ConfigObject\n}\n\nconst parseConfig = (key: string, config: Config, options: Partial<ConfigObject> = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  } as ConfigObject, config, options) as ConfigObject\n}\n\nconst parseConfigs = (\n  configs: Configs, \n  options: Partial<ConfigObject> = {}, \n  // eslint-disable-next-line no-unused-vars\n  callback?: (key: string, config: Config) => void,\n) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return lodash.get(config, `key`, key)\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    callback && callback(key, config)\n\n    return parseConfig(key, config, options)\n  }) as StandardizedConfigs\n}\n\nconst parseUniqueConfigs = (set: Configs, configs: Configs, options: Partial<ConfigObject>) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set: Configs, configs: Configs, options: Partial<ComponentOptions>) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components: Components, component: string) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs: Configs, callback = null) => {\n\n    const walked: StandardizedConfigs = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name: string, label: string, configs: Configs, type = `group`) => {\n\n    let path: string = groupTypes[type].path\n    let replacement: ComponentOptions = {}\n\n    each(configs, config => {\n      if (typeof config === `object` && config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name: string, configs: Configs) => {\n    return walkConfigs(configs, (key: string, config: Config) => {\n\n      if (typeof config === `object`) {\n        if (config.visibleIf) {\n          config.visibleIf = `${name}.${config.visibleIf}`\n        }\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n      \n    })\n  }\n\n  const addGroup = (\n    name: string, \n    label: string, \n    configs: Configs, \n    nesting = true, \n    type = `group`, \n    /* eslint-disable-next-line no-unused-vars */  \n    callback?: (_: string, _2: Config) => void,\n  ) => {\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key: string, config: ConfigObject) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name: string, label: string, configs: Configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        typeof config === `object` && lodash.set( config, `visibleIf`, `${name}.enabled` )\n      }\n    })\n\n    return configs as StandardizedConfigs\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  type AddFieldCallbackInnerFuncType = (key: string, config: Config ) => void\n\n  const addField = (\n    key: string, \n    // eslint-disable-next-line no-unused-vars\n    callback?: (arg: { insert: AddFieldCallbackInnerFuncType, modify: AddFieldCallbackInnerFuncType }) => void,\n  ) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert: AddFieldCallbackInnerFuncType = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        fields[key] = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n      }\n\n      const modify: AddFieldCallbackInnerFuncType = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback && callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label: string, configs: Configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = (definitions: Definitions) => {\n\n  const configs: Configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options: Partial<ConfigObject> = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key: string, component?: ComponentOptions) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component) as ComponentOptions\n}\n\nconst parseComponents = (components: Components) => {\n  return mapValues(components, (component, key: string) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  }) as Components\n}\n\nconst parseComponentsFromConfigs = (configs: Configs, structure: Components = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: Components = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (typeof config === `object` && has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }: SourceConfigs) => {\n\n  const name = getName ? await getName() : source\n  const label = getLabel ? await getLabel() : startCase(name)\n\n  const options: Source = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const config = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(config, grabComponents)\n    merge(options, {\n      config,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\n// This should be renamed parseSections (assuming we still need it)\n// const parseConfigs = (source: string, sections) => {\n\n//   const configs: Configs = {}\n\n//   const configKeys = []\n\n//   each(sections, (section, sectionKey) => {\n//     each(section.configs, (config: Config, key: string) => {\n\n//       const finalKey = config.key || key\n//       const finalSection = section.section || sectionKey\n//       const finalCategory = section.category || `setting`\n\n//       if (includes(configKeys, finalKey)) {\n//         throw new Error(`Source \"${source}\" has config with duplicate key \"${finalKey}\". No duplicate keys allowed.`)\n//       } else {\n//         configKeys.push(finalKey)\n//       }\n\n//       const configObj = {\n//         default: null,\n//         type: `input`,\n//         label: startCase(last(split(finalKey, `.`))),\n//         reference: finalKey,\n//         section: finalSection,\n//         category: finalCategory,\n//       }\n\n//       config = assign(configObj, config)\n\n//       configs[finalKey] = config\n//     })\n//   })\n\n//   return configs\n// }\n\nconst getMockResponse = (configs, options = null) => {\n\n  options = assign({\n    nested: false,\n  }, options)\n\n  const data = {}\n\n  each(configs, (config, key) => {\n    data[key] = config.default\n  })\n\n  if (options.nested) {\n    return convertToNested(data)\n  }\n\n  return data\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { getMockResponse, parseSource, SourceError }\n"],"names":["each","setWith","lodash","convertToNested","object","nested","value","key","Object","has","createConfigs","obj","dotObj","walk","into","prefix","entries","forEach","val","Array","isArray","join","isBoolean","isObject","last","split","startsWith","trimEnd","createConfigsFromJson","json","configs","flattenJson","initialPathPrefix","flattenedObject","flatten","keys","flatMap","reduce","acc","path","splitKey","lastPart","flattenJsonObject","defaultValue","config","default","type","map","createGroup","group","groupedConfigs","assign","mapValues","merge","size","createFeature","enabled","enabledKey","configSize","Error","modifiedConfigs","enabledConfig","visibleIf","mapKeys","createField","keyPrefix","callback","fields","label","styleClasses","subField","set","nestedConfigs","_","createSection","categoryName","sectionName","override","section","category","createSubSection","subsectionName","subsection","transformFields","field","get","overrides","model","console","log","filter","parseOnboarder","name","onboarder","schema","tab","index","id","order","Number","parseSchema","data","generateModel","kebabCase","startCase","unset","getType","standardizeConfig","skipDefaultCheck","parseConfig","options","docLink","docLinkText","hint","parseConfigs","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","toggleable","description","rootKey","parseSource","async","getComponents","getConfigs","getLabel","getName","source","grabComponents","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","parseComponents","getSettings","getTranslations","getUI","helpers","groupTypes","walkConfigs","walked","newConfig","newKey","addGroup","nesting","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","addFeature","addTab","addField","isVisible","required","disabled","readonly","hasAutoFocus","pattern","insert","modify","getHelpers","parseConfigsAndComponents","getMockResponse","SourceError","constructor","error","super","message","this"],"mappings":"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"}