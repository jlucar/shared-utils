{"version":3,"file":"index.modern.js","sources":["../src/convertToNested.ts","../src/createConfigs.ts","../src/createConfigsFromJson.ts","../src/createFeature.ts","../src/createField.ts","../src/createGroup.ts","../src/createSection.ts","../src/createSubSection.ts","../src/parseOnboarder.ts","../src/parseSource.ts"],"sourcesContent":["import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst convertToNested = object => {\n\n  const nested = {}\n\n  each(object, (value, key) => {\n    setWith(nested, key, value, Object)\n  })\n\n  return nested\n}\n\nexport { convertToNested }\n","import type { Configs, NestedConfigs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { has } = lodash\n\nconst createConfigs = (obj: NestedConfigs): Configs => {\n\n  function walk(into, obj, prefix = []) {\n    Object.entries(obj).forEach(([key, val]) => {\n      if (typeof val === `object` && !Array.isArray(val) && !has(val, `default`)) walk(into, val, [...prefix, key]);\n      else into[[...prefix, key].join(`.`)] = val;\n    });\n  }\n\n  const dotObj = {};\n  walk(dotObj, obj);\n\n  return dotObj;\n}\n\nexport { createConfigs }\n","import type {\n  Config,\n  Configs,\n} from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { each, isBoolean, isObject, last, split, startsWith, trimEnd } = lodash\n\n/**\n * TODO: This function doesn't know how to handle configs with an empty array value (preSelectedNewsletters) and the config will just be ignored\n */\nconst flattenJsonObject = (object: object, initialPathPrefix: string = ``) => {\n\n  function flatten(object, initialPathPrefix) {\n    if (!object || typeof object !== `object`) {\n      return [{ [initialPathPrefix]: object }]\n    }\n\n    const prefix = initialPathPrefix\n      ? Array.isArray(object)\n        ? initialPathPrefix\n        : `${initialPathPrefix}.`\n      : ``\n\n    return Object.keys(object)\n      .flatMap((key) =>\n        flatten(\n          object[key],\n          Array.isArray(object) ? `${prefix}[${key}]` : `${prefix}${key}`,\n        ),\n      )\n      .reduce((acc, path) => ({ ...acc, ...path }), [])\n  }\n\n  const flattenedObject = flatten(object, initialPathPrefix)\n\n  const configs = {}\n  each(flattenedObject, (value, key) => {\n    const splitKey = split(key, `.`)\n    const lastPart = last(splitKey)\n    if (startsWith(lastPart, `#`)) {\n      if (lastPart === `#value`) {\n        configs[trimEnd(key, `.#value`)] = value\n      }\n    } else {\n      configs[key] = value\n    }\n  })\n\n  return configs\n}\n\nconst createConfigsFromJson = (json: object): Configs => {\n\n  const configs = {}\n\n  const flattenJson = flattenJsonObject(json)\n\n  each(flattenJson, (value, key) => {\n\n    let defaultValue = value\n    if (isObject(value)) {\n      defaultValue = value[`#value`]\n    }\n\n    const config: Config = {\n      default: defaultValue,\n    }\n\n    if (isBoolean(defaultValue)) {\n      config.type = `switch`\n    }\n\n    configs[key] = config\n  })\n\n  return configs\n}\n\nexport { createConfigsFromJson }\n","import type { Config, Configs, NestedConfigs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nimport { createGroup } from '.'\n\nconst { assign, has, isBoolean, isObject, map, mapValues, merge, size } = lodash\n\nconst createFeature = (group: string, enabled: boolean | Config, configs: NestedConfigs = null): Configs => {\n\n  let enabledKey = null\n\n  const configSize = size(configs)\n\n  if (configSize !== 1) {\n    throw new Error(`The \"${group}\" group must only have one parent key, ${configSize} given.`)\n  }\n\n  const modifiedConfigs = mapValues(configs, (config, key) => {\n    if (!enabledKey) {\n\n      let enabledConfig = {\n        type: `switch`,\n        default: enabled,\n      }\n\n      if (isObject(enabled)) {\n        if (!has(enabled, `default`) || !isBoolean(enabled.default)) {\n          throw new Error(`A \"default\" boolean value must be supplied in the object`)\n        }\n\n        merge(enabledConfig, enabled)\n      }\n\n      config = assign({ enabled: enabledConfig }, config)\n      enabledKey = `${key}.enabled`\n    }\n\n    return config\n  })\n\n  let groupedConfigs = createGroup(group, modifiedConfigs)\n\n  map(groupedConfigs, (config, key) => {\n    if (key !== enabledKey) {\n      config.visibleIf = enabledKey\n    }\n\n    return config\n  })\n\n  return groupedConfigs\n}\n\nexport { createFeature }\n","import type { Configs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nimport { createGroup } from '.'\n\nconst { has, map, mapKeys } = lodash\n\nconst createField = (keyPrefix: string, callback = null): Configs => {\n\n  let fields: Configs = {}\n\n  const visibleIf = `${keyPrefix}.isVisible`\n\n  fields[`isVisible`] = {\n    type: `switch`,\n    label: `Visible`,\n    default: true,\n    group: keyPrefix,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`required`] = {\n    type: `switch`,\n    label: `Required`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`disabled`] = {\n    type: `switch`,\n    label: `Disabled`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`readonly`] = {\n    type: `switch`,\n    label: `Readonly`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`hasAutoFocus`] = {\n    type: `switch`,\n    label: `Autofocus`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`pattern`] = {\n    type: `input`,\n    label: `Pattern`,\n    default: ``,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-12`,\n  }\n\n  if (callback) {\n    fields = callback(fields)\n\n    map(fields, (subField, key) => {\n      if (!has(subField, `group`)) {\n        subField.group = keyPrefix\n      }\n      if (key !== `isVisible` && !has(subField, `visibleIf`)) {\n        subField.visibleIf = visibleIf\n      }\n      if (!has(subField, `styleClasses`)) {\n        subField.styleClasses = `col-md-12`\n      }\n    })\n  }\n\n  return createGroup(keyPrefix, mapKeys(fields, (subField, key) => {\n    return `${keyPrefix}.${key}`\n  }))\n}\n\nexport { createField }\n","import type { Configs, NestedConfigs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nimport { createConfigs } from '.'\n\nconst { map } = lodash\n\nconst createGroup = (group: string, configs: NestedConfigs): Configs => {\n\n  const groupedConfigs = createConfigs(configs)\n\n  map(groupedConfigs, config => {\n    config.group = group\n\n    return config\n  })\n\n  return groupedConfigs\n}\n\nexport { createGroup }\n","import type {\n  ConfigCategory,\n  Configs,\n  Section,\n} from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { merge } = lodash\n\nconst createSection = (configs: Configs, categoryName: ConfigCategory = null, sectionName: string = null, override: object = null): Section => {\n\n  const section: Section = {\n    configs: {},\n  }\n\n  if (configs) {\n    section.configs = configs\n  }\n\n  if (categoryName) {\n    section.category = categoryName\n  }\n\n  if (sectionName) {\n    section.section = sectionName\n  }\n\n  if (override) {\n    merge(section, override)\n  }\n\n  return section\n}\n\nexport {\n  createSection,\n}\n","import type {\n  Configs,\n} from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { mapValues, merge } = lodash\n\nconst createSubSection = (configs: Configs, subsectionName: string): Configs => {\n\n  return mapValues(configs, config => {\n    merge(config, {\n      subsection: subsectionName,\n    })\n\n    return config\n  })\n}\n\nexport {\n  createSubSection,\n}\n","import type {\n  Configs,\n  Onboarder,\n  OnboarderFields,\n  OnboarderTab,\n} from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { assign, has, map, mapValues, setWith } = lodash\n\nconst generateModel = schema => {\n\n  const data = {}\n\n  map(schema, tab => {\n    map(tab.fields, field => {\n      setWith(data, field.model, field.default, Object)\n    })\n  })\n\n  return data\n}\n\nconst transformFields = (fields: OnboarderFields, configs: Configs) => {\n\n  return fields.map(field => {\n\n    const key = typeof field === `string` ? field : field.key\n\n    if (has(configs, key)) {\n      const overrides = typeof field === `object` ? field : {}\n      delete overrides.key\n\n      return assign({\n        model: key,\n      }, configs[key], overrides)\n    }\n\n    console.log(`${key} is not a config!`)\n\n    return null\n  }).filter(field => {\n    if (field !== null) {\n      return field\n    }\n  })\n}\n\nconst parseSchema = (onboarder: Onboarder, configs: Configs) => {\n\n  return mapValues(onboarder, (tab, index) => {\n\n    const tabObj: OnboarderTab = {\n      id: index,\n      order: Number(index),\n      label: tab.label,\n      fields: transformFields(tab.fields, configs),\n    }\n\n    return tabObj\n  })\n\n}\n\nconst parseOnboarder = (name: string, onboarder: Onboarder, configs: Configs) => {\n\n  const obj: any = {\n    name: name,\n    schema: [],\n    model: {},\n  }\n\n  if (onboarder) {\n    const schema = parseSchema(onboarder, configs)\n\n    obj.schema = schema\n    obj.model = generateModel(schema)\n  }\n\n  return obj\n}\n\nexport { parseOnboarder }\n","import type { Config, Configs } from '@config-manager/types'\nimport lodash, { size } from 'lodash'\n\nimport { convertToNested } from '.'\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, split, startCase, unset } = lodash\n\nconst getType = (config) => {\n  switch (typeof config.default) {\n    case `boolean`:\n      return `switch`\n    default:\n      return `input`\n  }\n}\n\nconst standardizeConfig = (key, config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config\n}\n\nconst parseConfig = (key, config, options = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  }, config, options)\n}\n\nconst parseConfigs = (configs: Configs, options = {}, callback = null) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return config.key ? config.key : key\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    if (callback) {\n      callback(key, config)\n    }\n\n    return parseConfig(key, config, options)\n  })\n}\n\nconst parseUniqueConfigs = (set, configs, options) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set, configs, options) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components, component) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs, callback = null) => {\n\n    const walked = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name, label, configs, type = `group`) => {\n\n    let path = groupTypes[type].path\n    let replacement = {}\n\n    each(configs, config => {\n      if (config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name, configs) => {\n    return walkConfigs(configs, (key, config) => {\n\n      if (config.visibleIf) {\n        config.visibleIf = `${name}.${config.visibleIf}`\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n    })\n  }\n\n  const addGroup = (name, label, configs, nesting = true, type = `group`, callback = null) => {\n\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key, config) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name, label, configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        config.visibleIf = `${name}.enabled`\n      }\n    })\n\n    return configs\n  }\n\n  const addField = (key, callback = null) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        fields[key] = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n      }\n\n      const modify = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label, configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = definitions => {\n\n  const configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key, component = null) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component)\n}\n\nconst parseComponents = components => {\n  return mapValues(components, (component, key) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  })\n}\n\nconst parseComponentsFromConfigs = (configs, structure = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: { [key: string]: object } = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }) => {\n\n  const name = getName ? getName() : source\n  const label = getLabel ? getLabel() : startCase(name)\n\n  const options = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const configs = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(configs, grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\n// This should be renamed parseSections (assuming we still need it)\n// const parseConfigs = (source: string, sections) => {\n\n//   const configs: Configs = {}\n\n//   const configKeys = []\n\n//   each(sections, (section, sectionKey) => {\n//     each(section.configs, (config: Config, key: string) => {\n\n//       const finalKey = config.key || key\n//       const finalSection = section.section || sectionKey\n//       const finalCategory = section.category || `setting`\n\n//       if (includes(configKeys, finalKey)) {\n//         throw new Error(`Source \"${source}\" has config with duplicate key \"${finalKey}\". No duplicate keys allowed.`)\n//       } else {\n//         configKeys.push(finalKey)\n//       }\n\n//       const configObj = {\n//         default: null,\n//         type: `input`,\n//         label: startCase(last(split(finalKey, `.`))),\n//         reference: finalKey,\n//         section: finalSection,\n//         category: finalCategory,\n//       }\n\n//       config = assign(configObj, config)\n\n//       configs[finalKey] = config\n//     })\n//   })\n\n//   return configs\n// }\n\nconst getMockResponse = (configs, options = null) => {\n\n  options = assign({\n    nested: false,\n  }, options)\n\n  const data = {}\n\n  each(configs, (config, key) => {\n    data[key] = config.default\n  })\n\n  if (options.nested) {\n    return convertToNested(data)\n  }\n\n  return data\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { getMockResponse, parseSource, SourceError }\n"],"names":["each","setWith","lodash","convertToNested","object","nested","value","key","Object","has","createConfigs","obj","dotObj","walk","into","prefix","entries","forEach","val","Array","isArray","join","isBoolean","isObject","last","split","startsWith","trimEnd","createConfigsFromJson","json","configs","flattenJson","initialPathPrefix","flattenedObject","flatten","keys","flatMap","reduce","acc","path","splitKey","lastPart","flattenJsonObject","defaultValue","config","default","type","assign","map","mapValues","merge","size","createFeature","group","enabled","enabledKey","configSize","Error","modifiedConfigs","enabledConfig","groupedConfigs","createGroup","visibleIf","mapKeys","createField","keyPrefix","callback","fields","label","styleClasses","subField","createSection","categoryName","sectionName","override","section","category","createSubSection","subsectionName","subsection","transformFields","field","overrides","model","console","log","filter","parseOnboarder","name","onboarder","schema","tab","index","id","order","Number","parseSchema","data","generateModel","get","kebabCase","set","startCase","unset","getType","standardizeConfig","skipDefaultCheck","parseConfig","options","docLink","docLinkText","hint","parseConfigs","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","toggleable","description","rootKey","parseSource","async","getComponents","getConfigs","getLabel","getName","source","grabComponents","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","parseComponents","getSettings","getTranslations","getUI","helpers","groupTypes","walkConfigs","walked","newConfig","newKey","addGroup","nesting","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","addFeature","addTab","addField","isVisible","required","disabled","readonly","hasAutoFocus","pattern","insert","modify","getHelpers","parseConfigsAndComponents","getMockResponse","SourceError","constructor","error","super","message","this"],"mappings":"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"}