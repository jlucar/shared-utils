{"version":3,"file":"index.modern.js","sources":["../src/constants/CATEGORIES.ts","../src/fetchConfigs/transformationOptions.ts","../src/fetchConfigs/transformToNested.ts","../src/fetchConfigs/transformResponse.ts","../src/fetchConfigs/transformToConfigValues.ts","../src/createConfigsFromJson.ts","../src/parseSource/parseSource.ts","../src/parseSource/parseSourceConfigs.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport enum ConfigCategory {\n  Setting = `setting`,\n  Translation = `translation`,\n  UI = `ui`,\n  Feature = `feature`\n}\n\nexport enum ConfigCategoryPlurals {\n  Setting = `settings`,\n  Translation = `translations`,\n  UI = `ui`,\n  Feature = `features`\n}\n\n/* eslint-enable: no-unused-vars */\nconst CATEGORIES = {\n  [ConfigCategory.Setting]: {\n    plural: ConfigCategoryPlurals.Setting,\n    label: `Setting`,\n    labelPlural: `Settings`,\n    order: 1,\n  },\n  [ConfigCategory.Translation]: {\n    plural: ConfigCategoryPlurals.Translation,\n    label: `Translation`,\n    labelPlural: `Translations`,\n    order: 2,\n  },\n  [ConfigCategory.UI]: {\n    plural: ConfigCategoryPlurals.UI,\n    label: `UI`,\n    labelPlural: `UI`,\n    order: 3,\n  },\n  [ConfigCategory.Feature]: {\n    plural: ConfigCategoryPlurals.Feature,\n    label: `Feature`,\n    labelPlural: `Features`,\n    order: 4,\n  },\n}\n\nexport { CATEGORIES }\n","import lodash from 'lodash'\n\nconst { assign, mapValues } = lodash\n\nexport type TransformationOptions = {\n  nested: boolean,\n  categorized: boolean,\n}\n\nconst getTransformationOptions = (options: Partial<TransformationOptions> = {}): TransformationOptions => {\n\n  options = mapValues(options, () => true)\n\n  const opts: TransformationOptions = {\n    nested: false,\n    categorized: false,\n  }\n\n  return assign(opts, options)\n}\n\nexport { getTransformationOptions }\n","import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst transformToNested = object => {\n\n  const transformed = {}\n\n  each(object, (value, key) => {\n    setWith(transformed, key, value, Object)\n  })\n\n  return transformed\n}\n\nexport { transformToNested }\n","import lodash from 'lodash'\n\nimport { CATEGORIES } from '../constants'\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, get } = lodash\n\nconst helpTransformResponse = (response, callback = null) => {\n\n  const transformed = {}\n\n  each(response, (value, key) => {\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, value)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    transformed[key] = value\n  })\n\n  return transformed\n}\n\nconst transformResponse = (response, opts = {}, configs = null) => {\n\n  const options = getTransformationOptions(opts)\n\n  const transformed = helpTransformResponse(response, key => {\n\n    if (options.categorized) {\n\n      const config = get(configs, key)\n\n      if (config) {\n        key = `${CATEGORIES[config.category].plural}.${key}`\n      }\n    }\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(transformed)\n  }\n\n  return transformed\n}\n\nexport { transformResponse }\n","import lodash from 'lodash'\n\nimport { CATEGORIES } from '../constants'\nimport { getTransformationOptions } from './transformationOptions'\nimport { transformToNested } from './transformToNested'\n\nconst { each, has } = lodash\n\nconst transformFromConfigsToResponse = (configs, callback = null) => {\n\n  const response = {}\n\n  each(configs, (config, key) => {\n\n    let value = has(config, `value`) ? config.value : config.default\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, config)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    response[key] = value\n  })\n\n  return response\n}\n\nconst transformToConfigValues = (configs, opts = {}) => {\n\n  const options = getTransformationOptions(opts)\n\n  const response = transformFromConfigsToResponse(configs, (key, config) => {\n\n    key = options.categorized ? `${CATEGORIES[config.category].plural}.${key}` : key\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(response)\n  }\n\n  return response\n}\n\nexport { transformToConfigValues }\n","import lodash from 'lodash'\n\nimport type {\n  Config,\n  StandardizedConfigs,\n} from './types'\n\nconst { each, isBoolean, isObject, last, split, startsWith, trimEnd } = lodash\n\n/**\n * TODO: This function doesn't know how to handle configs with an empty array value (preSelectedNewsletters) and the config will just be ignored\n */\nconst flattenJsonObject = (object: object, initialPathPrefix: string = ``) => {\n\n  function flatten(object, initialPathPrefix) {\n    if (!object || typeof object !== `object`) {\n      return [{ [initialPathPrefix]: object }]\n    }\n\n    const prefix = initialPathPrefix\n      ? Array.isArray(object)\n        ? initialPathPrefix\n        : `${initialPathPrefix}.`\n      : ``\n\n    return Object.keys(object)\n      .flatMap((key) =>\n        flatten(\n          object[key],\n          Array.isArray(object) ? `${prefix}[${key}]` : `${prefix}${key}`,\n        ),\n      )\n      .reduce((acc, path) => ({ ...acc, ...path }), [])\n  }\n\n  const flattenedObject = flatten(object, initialPathPrefix)\n\n  const configs = {}\n  each(flattenedObject, (value, key) => {\n    const splitKey = split(key, `.`)\n    const lastPart = last(splitKey)\n    if (startsWith(lastPart, `#`)) {\n      if (lastPart === `#value`) {\n        configs[trimEnd(key, `.#value`)] = value\n      }\n    } else {\n      configs[key] = value\n    }\n  })\n\n  return configs\n}\n\nconst createConfigsFromJson = (json: object): StandardizedConfigs => {\n\n  const configs = {}\n\n  const flattenJson = flattenJsonObject(json)\n\n  each(flattenJson, (value, key) => {\n\n    let defaultValue = value\n    if (isObject(value)) {\n      defaultValue = value[`#value`]\n    }\n\n    const config: Config = {\n      default: defaultValue,\n    }\n\n    if (isBoolean(defaultValue)) {\n      config.type = `switch`\n    }\n\n    configs[key] = config\n  })\n\n  return configs\n}\n\nexport { createConfigsFromJson }\n","import lodash from 'lodash'\n\nimport type { Component, ComponentOptions, Components, Config, ConfigObject, Configs, Onboarder, Onboarders, OnboarderTabs, Source, StandardizedConfigs } from '../types'\n\nconst { assign, each, get, has, includes, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nexport type SourceConfigs = {\n  getComponents?: () => Promise<Components>,\n  getOnboarders?: () => Promise<Onboarder>,\n  getConfigs?: () => Promise<Configs>,\n  getLabel?: () => string | Promise<string | undefined>,\n  getName?: () => string | Promise<string | undefined>,\n  source?: string\n}\n\n// TODO: HelperFunctions is deprecated\nexport type HelperFunctions = ReturnType<typeof getHelpers>\nexport type Context = ReturnType<typeof getHelpers>\n\nexport type Definitions = {\n  [key: string]: DefinitionComponent\n}\n\n/* eslint-disable no-unused-vars */\nexport type DefinitionComponent = {\n  getConfigs?: (_: HelperFunctions) => Configs\n  getSettings?: (_: HelperFunctions) => Configs\n  getTranslations?: (_: HelperFunctions) => Configs\n  getUI?: (_: HelperFunctions) => Configs,\n  getFeatures?: (_: HelperFunctions) => Configs,\n  getOptions?: () => Component\n}\n\n/* eslint-enable no-unused-vars */\n\nconst getType = (config: Config) => {\n  if (typeof config === `object`) {\n    switch (typeof config.default) {\n      case `boolean`:\n        return `switch`\n    }\n  }\n\n  return `input`\n}\n\nconst standardizeConfig = (key: string, config: Config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config as ConfigObject\n}\n\nconst parseConfig = (key: string, config: Config, options: Partial<ConfigObject> = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  } as ConfigObject, config, options) as ConfigObject\n}\n\nconst parseConfigs = (\n  configs: Configs,\n  options: Partial<ConfigObject> = {},\n  // eslint-disable-next-line no-unused-vars\n  callback?: (key: string, config: Config) => void,\n) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return lodash.get(config, `key`, key)\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    callback && callback(key, config)\n\n    return parseConfig(key, config, options)\n  }) as StandardizedConfigs\n}\n\nconst parseUniqueConfigs = (set: Configs, configs: Configs, options: Partial<ConfigObject>) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set: Configs, configs: Configs, options: Partial<ComponentOptions>) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components: Components, component: string, helperType: string = `setting`) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const trackedGroups = []\n\n  const walkConfigs = (configs: Configs, callback = null) => {\n\n    const walked = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name: string, label: string, configs: Configs, type = `group`) => {\n\n    let path: string = groupTypes[type].path\n    let replacement: ComponentOptions = {}\n\n    each(configs, config => {\n      if (typeof config === `object` && config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name: string, configs: Configs) => {\n    return walkConfigs(configs, (key: string, config: Config) => {\n\n      if (typeof config === `object`) {\n        if (config.visibleIf) {\n          config.visibleIf = `${name}.${config.visibleIf}`\n        }\n\n        config.longLabel = `${startCase(name)} ⇢ ${config.longLabel ? config.longLabel : (config.label ? config.label : startCase(key))}`\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n    })\n  }\n\n  const addGroup = (\n    name: string,\n    label: string,\n    configs: Configs,\n    nesting = true,\n    type = `group`,\n    /* eslint-disable-next-line no-unused-vars */\n    callback?: (_: string, _2: Config) => void,\n  ) => {\n\n    // TODO: Eventually store a running list of problems so you can see a count of the issues\n    if (includes(trackedGroups, name)) {\n      console.warn(`\"${name}\" group already exists in \"${helperType}\"`)\n    } else {\n      trackedGroups.push(name)\n    }\n\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key: string, config: ConfigObject) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name: string, label: string, configs: Configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        typeof config === `object` && lodash.set(config, `visibleIf`, `${name}.enabled`)\n      }\n    })\n\n    return configs as StandardizedConfigs\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  type AddFieldCallbackInnerFuncType = (key: string, config: Config) => void\n  // eslint-disable-next-line no-unused-vars\n  type ModifyLabelCallbackInnerFuncType = (key: string) => void\n\n  const addField = (\n    key: string,\n    // eslint-disable-next-line no-unused-vars\n    callback?: (arg: {\n      insert: AddFieldCallbackInnerFuncType,\n      modify: AddFieldCallbackInnerFuncType,\n      modifyLabel: ModifyLabelCallbackInnerFuncType,\n    }) => void,\n  ) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    const prettyKey = startCase(key)\n\n    let label = prettyKey\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      longLabel: `${prettyKey} ⇢ Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      longLabel: `${prettyKey} ⇢ Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      longLabel: `${prettyKey} ⇢ Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      longLabel: `${prettyKey} ⇢ Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      longLabel: `${prettyKey} ⇢ Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      longLabel: `${prettyKey} ⇢ Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert: AddFieldCallbackInnerFuncType = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        const parsedConfig = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n\n        parsedConfig.longLabel = `${prettyKey} ⇢ ${parsedConfig.label}`\n\n        fields[key] = parsedConfig\n      }\n\n      const modify: AddFieldCallbackInnerFuncType = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      const modifyLabel: ModifyLabelCallbackInnerFuncType = newLabel => {\n        label = newLabel\n      }\n\n      callback && callback({\n        insert,\n        modify,\n        modifyLabel,\n      })\n    }\n\n    return addGroup(key, label, fields, true)\n  }\n\n  const addTab = (label: string, configs: Configs) => {\n\n    const name = `${helperType}-${kebabCase(label)}`\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = (definitions: Definitions) => {\n\n  const configs: Configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const helpParseConfigsWithCategory = (getCategoryFunction, category = `setting`) => {\n\n      let options: Partial<ConfigObject> = {\n        component: key,\n      }\n\n      const helpers = getHelpers(components, key, category)\n\n      if (category) {\n        options = assign(options, {\n          category: category,\n        })\n      }\n\n      const theseConfigs = getCategoryFunction(helpers)\n      if (size(theseConfigs)) {\n\n        const categories = get(components, [key, `categories`], [])\n        categories.push(category)\n        set(components, [key, `categories`], categories)\n\n        parseConfigsIntoCollection(configs, theseConfigs, options)\n      }\n    }\n\n    const {\n      getConfigs,\n      getFeatures,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    if (getConfigs) {\n      helpParseConfigsWithCategory(getConfigs)\n    } else {\n\n      if (getSettings) {\n        helpParseConfigsWithCategory(getSettings, `setting`)\n      }\n\n      if (getTranslations) {\n        helpParseConfigsWithCategory(getTranslations, `translation`)\n      }\n\n      if (getUI) {\n        helpParseConfigsWithCategory(getUI, `ui`)\n      }\n\n      if (getFeatures) {\n        helpParseConfigsWithCategory(getFeatures, `feature`)\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key: string, component?: ComponentOptions) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component) as ComponentOptions\n}\n\nconst parseComponents = (components: Components) => {\n  return mapValues(components, (component, key: string) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  }) as Components\n}\n\nconst parseComponentsFromConfigs = (configs: Configs, structure: Components = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: Components = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (typeof config === `object` && has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst standardizeConfigs = (configs: Configs, sourceConfigs): StandardizedConfigs => {\n\n  const standardizedConfigs = {}\n\n  each(configs, config => {\n\n    if (isObject(config) && !has(config, `key`)) {\n      throw new Error(`Onboarder config missing key!`)\n    }\n\n    const key: any = isObject(config) ? config.key : config\n\n    if (!has(sourceConfigs, key)) {\n      throw new Error(`Onboarder defines key \"${key}\" which does not exist.`)\n    }\n\n    if (isObject(config)) {\n      standardizedConfigs[key] = assign({}, sourceConfigs[key], config)\n    } else {\n      standardizedConfigs[key] = assign({}, sourceConfigs[key])\n    }\n  })\n\n  return standardizedConfigs\n}\n\nconst parseOnboarderTabs = (tabs, configs): OnboarderTabs => {\n\n  const parsedOnboardersTabs = {}\n\n  each(tabs, (tab, name) => {\n\n    parsedOnboardersTabs[name] = {\n      label: tab.label ? tab.label : startCase(name),\n      configs: standardizeConfigs(tab.configs, configs),\n    }\n  })\n\n  return parsedOnboardersTabs\n}\n\nconst parseOnboarders = (onboarders, configs): Onboarders => {\n\n  const parsedOnboarders = {}\n\n  each(onboarders, ({ getLabel, getTabs }, name) => {\n\n    parsedOnboarders[name] = {\n      label: getLabel ? getLabel() : startCase(name),\n      tabs: getTabs ? parseOnboarderTabs(getTabs(), configs) : {},\n    }\n  })\n\n  return parsedOnboarders\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, getOnboarders, source }: SourceConfigs) => {\n\n  const name = getName ? await getName() : source\n  const label = getLabel ? await getLabel() : startCase(name)\n\n  const options: Source = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const configs = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(configs, grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  } else {\n    let { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  if (getOnboarders) {\n    options.onboarders = parseOnboarders(await getOnboarders(), options.configs)\n  }\n\n  return options\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { parseSource, SourceError }\n","import { parseSource, SourceConfigs } from './parseSource'\n\nconst parseSourceConfigs = async (source: string, stack: SourceConfigs) => {\n\n  const parsedSource = await parseSource({\n    source,\n    ...stack,\n  })\n\n  return parsedSource.configs\n}\n\nexport { parseSourceConfigs }\n"],"names":["ConfigCategory","ConfigCategoryPlurals","CATEGORIES","Setting","plural","label","labelPlural","order","Translation","UI","Feature","assign","mapValues","lodash","getTransformationOptions","options","nested","categorized","each","setWith","transformToNested","object","transformed","value","key","Object","get","transformResponse","response","opts","configs","callback","newKey","newValue","helpTransformResponse","config","category","has","transformToConfigValues","default","transformFromConfigsToResponse","isBoolean","isObject","last","split","startsWith","trimEnd","json","flattenJson","initialPathPrefix","flatten","prefix","Array","isArray","keys","flatMap","reduce","acc","path","flattenedObject","splitKey","lastPart","flattenJsonObject","defaultValue","type","includes","kebabCase","mapKeys","merge","set","size","startCase","unset","getType","standardizeConfig","skipDefaultCheck","Error","parseConfig","docLink","docLinkText","hint","parseConfigs","parseComponent","component","toggleable","description","rootKey","standardizeConfigs","sourceConfigs","standardizedConfigs","parseOnboarderTabs","tabs","parsedOnboardersTabs","tab","name","parseSource","async","getComponents","getConfigs","getLabel","getName","getOnboarders","source","grabComponents","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","parseComponents","helpParseConfigsWithCategory","getCategoryFunction","helperType","groupTypes","group","trackedGroups","walkConfigs","walked","newConfig","addGroup","nesting","console","warn","push","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","visibleIf","longLabel","addFeature","enabled","addTab","addField","fields","prettyKey","isVisible","styleClasses","required","disabled","readonly","hasAutoFocus","pattern","parsedConfig","modify","modifyLabel","newLabel","insert","getHelpers","theseConfigs","helpers","categories","parseUniqueConfigs","parseConfigsIntoCollection","getFeatures","getSettings","getTranslations","getUI","parseConfigsAndComponents","onboarders","getTabs","parsedOnboarders","parseOnboarders","SourceError","constructor","error","super","message","this","parseSourceConfigs","stack","_extends"],"mappings":"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"}