import e from"lodash";const{assign:t,mapValues:n}=e,l=(e={})=>(e=n(e,()=>!0),t({nested:!1,categorized:!1},e)),{each:o,get:s}=e,a=(e,t={},n=null)=>{const a=l(t),r=((e,t=null)=>{const n={};return o(e,(e,l)=>{if(t){const{key:n,value:o}=t(l,e);n&&(l=n),o&&(e=o)}n[l]=e}),n})(e,e=>{if(a.categorized){const t=s(n,e);t&&(e=`${t.category}.${e}`)}return{key:e}});return a.nested?g(r):r},{each:r,has:i}=e,c=(e,t={})=>{const n=l(t),o=((e,t=null)=>{const n={};return r(e,(e,l)=>{let o=i(e,"value")?e.value:e.default;if(t){const{key:n,value:s}=t(l,e);n&&(l=n),s&&(o=s)}n[l]=o}),n})(e,(e,t)=>({key:e=n.categorized?`${t.category}.${e}`:e}));return n.nested?g(o):o},{each:u,setWith:d}=e,g=e=>{const t={};return u(e,(e,n)=>{d(t,n,e,Object)}),t},{assign:f,each:b,get:p,has:y,isObject:m,kebabCase:h,last:$,mapKeys:v,mapValues:k,merge:L,set:w,size:C,split:I,startCase:O,unset:E}=e,V=e=>"boolean"==typeof e.default?"switch":"input",F=(e,t,n=!1)=>{if(m(t)){if(!n&&!y(t,"default"))throw new Error(`Config "${e}" is missing a "default" value.`)}else t={default:t};return t},j=(e,t,n={})=>{if(delete(t=F(e,t)).key,t.docLink){const e=`Documentation on this feature can be found <a href="${t.docLink}">here</a>.`;t.hint=t.hint?e+`<br>${t.hint}`:e,delete t.docLink}return f({default:null,type:V(t),label:O($(I(e,"."))),category:"setting"},t,n)},z=(e,t={},n=null)=>(e=v(e,(e,t)=>e.key?e.key:t),k(e,(e,l)=>(n&&n(l,e),j(l,e,t)))),D=(e,t,n)=>{L(e,((e,t,n)=>z(t,n,t=>{if(y(e,t))throw new Error(`Duplicate key: "${t}"`)}))(e,t,n))},R=(e,t=null)=>f({label:O($(I(e,"."))),order:0,toggleable:!1,description:null,rootKey:null},t),q=async({getComponents:e,getConfigs:t,getLabel:n,getName:l,source:o})=>{const s=l?l():o,a={name:s,label:n?n():O(s)},r=e?await e():null;if(t){const e=z(await t()),n=((e,t={})=>{const n={};let l=!1;return b(e,e=>{if(y(e,"component")){if(!y(n,e.component)){let l={};if(y(t,e.component)){const{getOptions:n}=t[e.component];l=n?n():t[e.component]}n[e.component]=R(e.component,l)}}else l=!0}),l&&C(n)&&(n.unsorted=R("unsorted",{order:999})),n})(e,r);L(a,{configs:e,components:n})}else{const{components:e,configs:t}=(e=>{const t={},n=(e=>k(e,(e,t)=>{const{getOptions:n}=e;return R(t,n?n():null)}))(e);return b(e,(e,l)=>{const{getConfigs:o,getSettings:s,getTranslations:a,getUI:r}=e,i={component:l},c=((e,t)=>{const n={group:{path:"groups"},tab:{path:"tabs"}},l=(e,t=null)=>{const n={};return b(e,(e,l)=>{if(e=F(l,e),t){const{config:o,key:s}=t(l,e);n[s]=o}else n[l]=e}),n},o=(o,s,a,r=!0,i="group",c=null)=>(((l,o,s,a="group")=>{let r=n[a].path,i={};b(s,l=>{if(l.group){const o=l.group;b(n,n=>{const l=p(e,[t,n.path,o]);if(l){w(i,[n.path,o],l),E(e,[t,n.path,o]);const s=p(e,[t,n.path],{});0===C(s)&&E(e,[t,n.path])}})}}),w(e,[t,r,l],f({label:o},i))})(o,s,a,i),l(a,(e,t)=>(t.group=t.group?`${o}.${t.group}`:o,c&&c(e,t),{key:r?`${o}.${e}`:e,config:t})));return{addNested:(e,t)=>l(t,(t,n)=>(n.visibleIf&&(n.visibleIf=`${e}.${n.visibleIf}`),n.longLabel=`${O(e)} ⇢ ${n.longLabel?n.longLabel:n.label?n.label:O(t)}`,{key:`${e}.${t}`,config:n})),addFeature:(e,t,n,l=!1,s=!0)=>{if(y(n,"enabled"))throw new Error(`Feature "${e}" should not contain a property named "enabled".`);return n=f({enabled:F("enabled",l)},n),o(e,t,n,s,"group",(t,n)=>{"enabled"!==t&&(n.visibleIf=`${e}.enabled`)})},addGroup:o,addTab:(e,t)=>{const n=h(e);return o(n,e,t,!1,"tab")},addField:(e,t=null)=>{let n={};const l=`${e}.isVisible`,s=O(e);if(n.isVisible={default:!0,label:"Visible",longLabel:`${s} ⇢ Visible`,styleClasses:"col-md-2"},n.required={default:!1,label:"Required",longLabel:`${s} ⇢ Required`,visibleIf:l,styleClasses:"col-md-2"},n.disabled={default:!1,label:"Disabled",longLabel:`${s} ⇢ Disabled`,visibleIf:l,styleClasses:"col-md-2"},n.readonly={default:!1,label:"Readonly",longLabel:`${s} ⇢ Readonly`,visibleIf:l,styleClasses:"col-md-2"},n.hasAutoFocus={default:!1,label:"Autofocus",longLabel:`${s} ⇢ Autofocus`,visibleIf:l,styleClasses:"col-md-2"},n.pattern={default:"",label:"Pattern",longLabel:`${s} ⇢ Pattern`,visibleIf:l,styleClasses:"col-md-12"},t){const e=(e,t)=>{if(y(n,e))throw new Error(`Field ${e} already exists!`);const o=j(e,t,{visibleIf:l,styleClasses:"col-md-12"});o.longLabel=`${s} ⇢ ${o.label}`,n[e]=o},o=(e,t)=>{L(n[e],F(e,t,!0))};t({insert:e,modify:o})}return o(e,O(e),n,!0)}}})(n,l);o?D(t,o(c),i):(s&&D(t,s(c),f(i,{category:"setting"})),a&&D(t,a(c),f(i,{category:"translation"})),r&&D(t,r(c),f(i,{category:"ui"})))}),{configs:t,components:n}})(r);L(a,{configs:t,components:e})}return a};class x extends Error{constructor(e,t){super(`${t.message} ("${e}" source)`),this.name="SourceError"}}function A(){return A=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var l in n)Object.prototype.hasOwnProperty.call(n,l)&&(e[l]=n[l])}return e},A.apply(this,arguments)}const P=async(e,t)=>(await q(A({source:e},t))).configs;export{x as SourceError,l as getTransformationOptions,q as parseSource,P as parseSourceConfigs,a as transformResponse,c as transformToConfigValues,g as transformToNested};
//# sourceMappingURL=index.modern.js.map
