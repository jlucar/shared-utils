import e from"lodash";const{assign:t,mapValues:o}=e,n=(e={})=>(e=o(e,()=>!0),t({nested:!1,categorized:!1},e)),{each:l,setWith:s}=e,a=e=>{const t={};return l(e,(e,o)=>{s(t,o,e,Object)}),t},{each:r,get:i}=e,c=(e,t={},o=null)=>{const l=n(t),s=((e,t=null)=>{const o={};return r(e,(e,n)=>{if(t){const{key:o,value:l}=t(n,e);o&&(n=o),l&&(e=l)}o[n]=e}),o})(e,e=>{if(l.categorized){const t=i(o,e);t&&(e=`${t.category}.${e}`)}return{key:e}});return l.nested?a(s):s},{each:u,has:d}=e,f=(e,t={})=>{const o=n(t),l=((e,t=null)=>{const o={};return u(e,(e,n)=>{let l=d(e,"value")?e.value:e.default;if(t){const{key:o,value:s}=t(n,e);o&&(n=o),s&&(l=s)}o[n]=l}),o})(e,(e,t)=>({key:e=o.categorized?`${t.category}.${e}`:e}));return o.nested?a(l):l},{assign:b,each:g,get:p,has:y,isObject:m,kebabCase:h,last:$,mapKeys:v,mapValues:w,merge:k,set:L,size:C,split:I,startCase:j,unset:O}=e,E=e=>"object"==typeof e&&"boolean"==typeof e.default?"switch":"input",V=(e,t,o=!1)=>{if(m(t)){if(!o&&!y(t,"default"))throw new Error(`Config "${e}" is missing a "default" value.`)}else t={default:t};return t},F=(e,t,o={})=>{if(delete(t=V(e,t)).key,t.docLink){const e=`Documentation on this feature can be found <a href="${t.docLink}">here</a>.`;t.hint=t.hint?e+`<br>${t.hint}`:e,delete t.docLink}return b({default:null,type:E(t),label:j($(I(e,"."))),category:"setting"},t,o)},z=(t,o={},n)=>(t=v(t,(t,o)=>e.get(t,"key",o)),w(t,(e,t)=>(n&&n(t,e),F(t,e,o)))),D=(e,t,o)=>{k(e,((e,t,o)=>z(t,o,t=>{if(y(e,t))throw new Error(`Duplicate key: "${t}"`)}))(e,t,o))},R=(e,t)=>b({label:j($(I(e,"."))),order:0,toggleable:!1,description:null,rootKey:null},t),q=async({getComponents:t,getConfigs:o,getLabel:n,getName:l,source:s})=>{const a=l?await l():s,r={name:a,label:n?await n():j(a)},i=t?await t():null;if(o){const e=z(await o()),t=((e,t={})=>{const o={};let n=!1;return g(e,e=>{if("object"==typeof e&&y(e,"component")){if(!y(o,e.component)){let n={};if(y(t,e.component)){const{getOptions:o}=t[e.component];n=o?o():t[e.component]}o[e.component]=R(e.component,n)}}else n=!0}),n&&C(o)&&(o.unsorted=R("unsorted",{order:999})),o})(e,i);k(r,{config:e,components:t})}else{const{components:t,configs:o}=(t=>{const o={},n=(e=>w(e,(e,t)=>{const{getOptions:o}=e;return R(t,o?o():null)}))(t);return g(t,(t,l)=>{const{getConfigs:s,getSettings:a,getTranslations:r,getUI:i}=t,c={component:l},u=((t,o)=>{const n={group:{path:"groups"},tab:{path:"tabs"}},l=(e,t=null)=>{const o={};return g(e,(e,n)=>{if(e=V(n,e),t){const{config:l,key:s}=t(n,e);o[s]=l}else o[n]=e}),o},s=(e,s,a,r=!0,i="group",c)=>(((e,l,s,a="group")=>{let r=n[a].path,i={};g(s,e=>{if("object"==typeof e&&e.group){const l=e.group;g(n,e=>{const n=p(t,[o,e.path,l]);if(n){L(i,[e.path,l],n),O(t,[o,e.path,l]);const s=p(t,[o,e.path],{});0===C(s)&&O(t,[o,e.path])}})}}),L(t,[o,r,e],b({label:l},i))})(e,s,a,i),l(a,(t,o)=>(o.group=o.group?`${e}.${o.group}`:e,c&&c(t,o),{key:r?`${e}.${t}`:t,config:o})));return{addNested:(e,t)=>l(t,(t,o)=>("object"==typeof o&&(o.visibleIf&&(o.visibleIf=`${e}.${o.visibleIf}`),o.longLabel=`${j(e)} ⇢ ${o.longLabel?o.longLabel:o.label?o.label:j(t)}`),{key:`${e}.${t}`,config:o})),addFeature:(t,o,n,l=!1,a=!0)=>{if(y(n,"enabled"))throw new Error(`Feature "${t}" should not contain a property named "enabled".`);return n=b({enabled:V("enabled",l)},n),s(t,o,n,a,"group",(o,n)=>{"enabled"!==o&&"object"==typeof n&&e.set(n,"visibleIf",`${t}.enabled`)})},addGroup:s,addTab:(e,t)=>{const o=h(e);return s(o,e,t,!1,"tab")},addField:(e,t)=>{let o={};const n=`${e}.isVisible`,l=j(e);if(o.isVisible={default:!0,label:"Visible",longLabel:`${l} ⇢ Visible`,styleClasses:"col-md-2"},o.required={default:!1,label:"Required",longLabel:`${l} ⇢ Required`,visibleIf:n,styleClasses:"col-md-2"},o.disabled={default:!1,label:"Disabled",longLabel:`${l} ⇢ Disabled`,visibleIf:n,styleClasses:"col-md-2"},o.readonly={default:!1,label:"Readonly",longLabel:`${l} ⇢ Readonly`,visibleIf:n,styleClasses:"col-md-2"},o.hasAutoFocus={default:!1,label:"Autofocus",longLabel:`${l} ⇢ Autofocus`,visibleIf:n,styleClasses:"col-md-2"},o.pattern={default:"",label:"Pattern",longLabel:`${l} ⇢ Pattern`,visibleIf:n,styleClasses:"col-md-12"},t){const e=(e,t)=>{if(y(o,e))throw new Error(`Field ${e} already exists!`);const s=F(e,t,{visibleIf:n,styleClasses:"col-md-12"});s.longLabel=`${l} ⇢ ${s.label}`,o[e]=s},s=(e,t)=>{k(o[e],V(e,t,!0))};t&&t({insert:e,modify:s})}return s(e,j(e),o,!0)}}})(n,l);s?D(o,s(u),c):(a&&D(o,a(u),b(c,{category:"setting"})),r&&D(o,r(u),b(c,{category:"translation"})),i&&D(o,i(u),b(c,{category:"ui"})))}),{configs:o,components:n}})(i);k(r,{configs:o,components:t})}return r};class x extends Error{constructor(e,t){super(`${t.message} ("${e}" source)`),this.name="SourceError"}}function A(){return A=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e},A.apply(this,arguments)}const P=async(e,t)=>(await q(A({source:e},t))).configs;export{x as SourceError,n as getTransformationOptions,q as parseSource,P as parseSourceConfigs,c as transformResponse,f as transformToConfigValues,a as transformToNested};
//# sourceMappingURL=index.modern.js.map
