{"version":3,"file":"index.cjs","sources":["../src/fetchConfigs/transformationOptions.ts","../src/fetchConfigs/transformResponse.ts","../src/fetchConfigs/transformToConfigValues.ts","../src/fetchConfigs/transformToNested.ts","../src/parseSource/parseSource.ts","../src/parseSource/parseSourceConfigs.ts"],"sourcesContent":["import lodash from 'lodash'\n\nconst { assign, mapValues } = lodash\n\nexport type TransformationOptions = {\n  nested: boolean,\n  categorized: boolean,\n}\n\nconst getTransformationOptions = (options: Partial<TransformationOptions> = {}): TransformationOptions => {\n\n  options = mapValues(options, () => true)\n\n  const opts: TransformationOptions = {\n    nested: false,\n    categorized: false,\n  }\n\n  return assign(opts, options)\n}\n\nexport { getTransformationOptions }\n","import lodash from 'lodash'\n\nimport { getTransformationOptions, transformToNested } from '.'\n\nconst { each, get } = lodash\n\nconst helpTransformResponse = (response, callback = null) => {\n\n  const transformed = {}\n\n  each(response, (value, key) => {\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, value)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    transformed[key] = value\n  })\n\n  return transformed\n}\n\nconst transformResponse = (response, opts = {}, configs = null) => {\n\n  const options = getTransformationOptions(opts)\n\n  const transformed = helpTransformResponse(response, key => {\n\n    if (options.categorized) {\n\n      const config = get(configs, key)\n\n      if (config) {\n        key = `${config.category}.${key}`\n      }\n    }\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(transformed)\n  }\n\n  return transformed\n}\n\nexport { transformResponse }\n","import lodash from 'lodash'\n\nimport { getTransformationOptions, transformToNested } from '.'\n\nconst { each, has } = lodash\n\nconst transformFromConfigsToResponse = (configs, callback = null) => {\n\n  const response = {}\n\n  each(configs, (config, key) => {\n\n    let value = has(config, `value`) ? config.value : config.default\n\n    if (callback) {\n\n      const {\n        key: newKey,\n        value: newValue,\n      } = callback(key, config)\n\n      if (newKey) {\n        key = newKey\n      }\n\n      if (newValue) {\n        value = newValue\n      }\n    }\n\n    response[key] = value\n  })\n\n  return response\n}\n\nconst transformToConfigValues = (configs, opts = {}) => {\n\n  const options = getTransformationOptions(opts)\n\n  const response = transformFromConfigsToResponse(configs, (key, config) => {\n\n    key = options.categorized ? `${config.category}.${key}` : key\n\n    return {\n      key,\n    }\n  })\n\n  if (options.nested) {\n    return transformToNested(response)\n  }\n\n  return response\n}\n\nexport { transformToConfigValues }\n","import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst transformToNested = object => {\n\n  const transformed = {}\n\n  each(object, (value, key) => {\n    setWith(transformed, key, value, Object)\n  })\n\n  return transformed\n}\n\nexport { transformToNested }\n","import type { Config, Configs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nconst getType = (config) => {\n  switch (typeof config.default) {\n    case `boolean`:\n      return `switch`\n    default:\n      return `input`\n  }\n}\n\nconst standardizeConfig = (key, config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config\n}\n\nconst parseConfig = (key, config, options = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  }, config, options)\n}\n\nconst parseConfigs = (configs: Configs, options = {}, callback = null) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return config[`key`] ? config[`key`] : key\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    if (callback) {\n      callback(key, config)\n    }\n\n    return parseConfig(key, config, options)\n  })\n}\n\nconst parseUniqueConfigs = (set, configs, options) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set, configs, options) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components, component) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs, callback = null) => {\n\n    const walked = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name, label, configs, type = `group`) => {\n\n    let path = groupTypes[type].path\n    let replacement = {}\n\n    each(configs, config => {\n      if (config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name, configs) => {\n    return walkConfigs(configs, (key, config) => {\n\n      if (config.visibleIf) {\n        config.visibleIf = `${name}.${config.visibleIf}`\n      }\n\n      config.longLabel = `${startCase(name)} ⇢ ${config.longLabel ? config.longLabel : (config.label ? config.label : startCase(key))}`\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n    })\n  }\n\n  const addGroup = (name, label, configs, nesting = true, type = `group`, callback = null) => {\n\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key, config) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name, label, configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        config.visibleIf = `${name}.enabled`\n      }\n    })\n\n    return configs\n  }\n\n  const addField = (key, callback = null) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    const prettyKey = startCase(key)\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      longLabel: `${prettyKey} ⇢ Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      longLabel: `${prettyKey} ⇢ Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      longLabel: `${prettyKey} ⇢ Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      longLabel: `${prettyKey} ⇢ Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      longLabel: `${prettyKey} ⇢ Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      longLabel: `${prettyKey} ⇢ Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        const parsedConfig = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n\n        parsedConfig.longLabel = `${prettyKey} ⇢ ${parsedConfig.label}`\n\n        fields[key] = parsedConfig\n      }\n\n      const modify = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label, configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = definitions => {\n\n  const configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key, component = null) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component)\n}\n\nconst parseComponents = components => {\n  return mapValues(components, (component, key) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  })\n}\n\nconst parseComponentsFromConfigs = (configs, structure = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: { [key: string]: object } = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }: { getComponents?: any, getConfigs?: any, getLabel?: any, getName?: any, source?: string }) => {\n\n  const name = getName ? getName() : source\n  const label = getLabel ? getLabel() : startCase(name)\n\n  const options: {\n    name: any,\n    label: any,\n    configs?: any,\n    components?: any\n  } = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const configs = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(configs, grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\n// This should be renamed parseSections (assuming we still need it)\n// const parseConfigs = (source: string, sections) => {\n\n//   const configs: Configs = {}\n\n//   const configKeys = []\n\n//   each(sections, (section, sectionKey) => {\n//     each(section.configs, (config: Config, key: string) => {\n\n//       const finalKey = config.key || key\n//       const finalSection = section.section || sectionKey\n//       const finalCategory = section.category || `setting`\n\n//       if (includes(configKeys, finalKey)) {\n//         throw new Error(`Source \"${source}\" has config with duplicate key \"${finalKey}\". No duplicate keys allowed.`)\n//       } else {\n//         configKeys.push(finalKey)\n//       }\n\n//       const configObj = {\n//         default: null,\n//         type: `input`,\n//         label: startCase(last(split(finalKey, `.`))),\n//         reference: finalKey,\n//         section: finalSection,\n//         category: finalCategory,\n//       }\n\n//       config = assign(configObj, config)\n\n//       configs[finalKey] = config\n//     })\n//   })\n\n//   return configs\n// }\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { parseSource, SourceError }\n","import { parseSource } from '../'\n\nconst parseSourceConfigs = async (source: string, stack) => {\n\n  const parsedSource = await parseSource({\n    source,\n    ...stack,\n  })\n\n  return parsedSource.configs\n}\n\nexport { parseSourceConfigs }\n"],"names":["assign","lodash","mapValues","getTransformationOptions","options","nested","categorized","each","get","has","setWith","transformToNested","object","transformed","value","key","Object","isObject","kebabCase","last","mapKeys","merge","set","size","split","startCase","unset","getType","config","standardizeConfig","skipDefaultCheck","Error","default","parseConfig","docLink","docLinkText","hint","type","label","category","parseConfigs","configs","callback","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","order","toggleable","description","rootKey","parseSource","_ref","getComponents","getConfigs","getLabel","getName","source","_temp3","grabComponents","_temp","Promise","resolve","then","_getConfigs","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","_parseConfigsAndCompo","parseComponents","getSettings","getTranslations","getUI","helpers","groupTypes","group","path","tab","walkConfigs","walked","_callback","addGroup","name","nesting","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","visibleIf","longLabel","addFeature","enabled","addTab","addField","fields","prettyKey","isVisible","styleClasses","required","disabled","readonly","hasAutoFocus","pattern","insert","parsedConfig","modify","getHelpers","e","reject","SourceError","_Error","error","_this","call","this","message","stack","_extends","parsedSource","response","opts","newKey","newValue","helpTransformResponse","transformFromConfigsToResponse"],"mappings":"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"}