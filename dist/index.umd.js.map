{"version":3,"file":"index.umd.js","sources":["../src/convertToNested.ts","../src/parseSource.ts"],"sourcesContent":["import lodash from 'lodash'\n\nconst { each, setWith } = lodash\n\nconst convertToNested = object => {\n\n  const nested = {}\n\n  each(object, (value, key) => {\n    setWith(nested, key, value, Object)\n  })\n\n  return nested\n}\n\nexport { convertToNested }\n","import type { Config, Configs } from '@config-manager/types'\nimport lodash from 'lodash'\n\nimport { convertToNested } from '.'\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nconst getType = (config) => {\n  switch (typeof config.default) {\n    case `boolean`:\n      return `switch`\n    default:\n      return `input`\n  }\n}\n\nconst standardizeConfig = (key, config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config\n}\n\nconst parseConfig = (key, config, options = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  }, config, options)\n}\n\nconst parseConfigs = (configs: Configs, options = {}, callback = null) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return config[`key`] ? config[`key`] : key\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    if (callback) {\n      callback(key, config)\n    }\n\n    return parseConfig(key, config, options)\n  })\n}\n\nconst parseUniqueConfigs = (set, configs, options) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set, configs, options) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components, component) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs, callback = null) => {\n\n    const walked = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name, label, configs, type = `group`) => {\n\n    let path = groupTypes[type].path\n    let replacement = {}\n\n    each(configs, config => {\n      if (config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name, configs) => {\n    return walkConfigs(configs, (key, config) => {\n\n      if (config.visibleIf) {\n        config.visibleIf = `${name}.${config.visibleIf}`\n      }\n\n      config.longLabel = `${startCase(name)} ⇢ ${config.longLabel ? config.longLabel : (config.label ? config.label : startCase(key))}`\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n    })\n  }\n\n  const addGroup = (name, label, configs, nesting = true, type = `group`, callback = null) => {\n\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key, config) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name, label, configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        config.visibleIf = `${name}.enabled`\n      }\n    })\n\n    return configs\n  }\n\n  const addField = (key, callback = null) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    const prettyKey = startCase(key)\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      longLabel: `${prettyKey} ⇢ Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      longLabel: `${prettyKey} ⇢ Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      longLabel: `${prettyKey} ⇢ Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      longLabel: `${prettyKey} ⇢ Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      longLabel: `${prettyKey} ⇢ Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      longLabel: `${prettyKey} ⇢ Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        const parsedConfig = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n\n        parsedConfig.longLabel = `${prettyKey} ⇢ ${parsedConfig.label}`\n\n        fields[key] = parsedConfig\n      }\n\n      const modify = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label, configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = definitions => {\n\n  const configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key, component = null) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component)\n}\n\nconst parseComponents = components => {\n  return mapValues(components, (component, key) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  })\n}\n\nconst parseComponentsFromConfigs = (configs, structure = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: { [key: string]: object } = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }) => {\n\n  const name = getName ? getName() : source\n  const label = getLabel ? getLabel() : startCase(name)\n\n  const options = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const configs = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(configs, grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\n// This should be renamed parseSections (assuming we still need it)\n// const parseConfigs = (source: string, sections) => {\n\n//   const configs: Configs = {}\n\n//   const configKeys = []\n\n//   each(sections, (section, sectionKey) => {\n//     each(section.configs, (config: Config, key: string) => {\n\n//       const finalKey = config.key || key\n//       const finalSection = section.section || sectionKey\n//       const finalCategory = section.category || `setting`\n\n//       if (includes(configKeys, finalKey)) {\n//         throw new Error(`Source \"${source}\" has config with duplicate key \"${finalKey}\". No duplicate keys allowed.`)\n//       } else {\n//         configKeys.push(finalKey)\n//       }\n\n//       const configObj = {\n//         default: null,\n//         type: `input`,\n//         label: startCase(last(split(finalKey, `.`))),\n//         reference: finalKey,\n//         section: finalSection,\n//         category: finalCategory,\n//       }\n\n//       config = assign(configObj, config)\n\n//       configs[finalKey] = config\n//     })\n//   })\n\n//   return configs\n// }\n\nconst getMockResponse = (configs, options = null) => {\n\n  options = assign({\n    nested: false,\n  }, options)\n\n  const data = {}\n\n  each(configs, (config, key) => {\n    data[key] = config.default\n  })\n\n  if (options.nested) {\n    return convertToNested(data)\n  }\n\n  return data\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { getMockResponse, parseSource, SourceError }\n"],"names":["each","lodash","setWith","convertToNested","object","nested","value","key","Object","assign","get","has","isObject","kebabCase","last","mapKeys","mapValues","merge","set","size","split","startCase","unset","getType","config","standardizeConfig","skipDefaultCheck","Error","default","parseConfig","options","docLink","docLinkText","hint","type","label","category","parseConfigs","configs","callback","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","order","toggleable","description","rootKey","SourceError","source","error","_this","message","this","name","data","parseSource","_ref","getComponents","getConfigs","getLabel","getName","grabComponents","then","_getConfigs","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","_parseConfigsAndCompo","parseComponents","getSettings","getTranslations","getUI","helpers","groupTypes","group","path","tab","walkConfigs","walked","_callback","addGroup","nesting","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","visibleIf","longLabel","addFeature","enabled","addTab","addField","fields","prettyKey","isVisible","styleClasses","required","disabled","readonly","hasAutoFocus","pattern","insert","parsedConfig","modify","getHelpers","_temp","_temp3","e","Promise","reject"],"mappings":"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"}