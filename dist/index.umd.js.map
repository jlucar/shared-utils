{"version":3,"file":"index.umd.js","sources":["../src/convertToNested.ts","../src/createConfigs.ts","../src/createConfigsFromJson.ts","../src/createGroup.ts","../src/createFeature.ts","../src/createField.ts","../src/createSection.ts","../src/createSubSection.ts","../src/parseOnboarder.ts","../src/parseSource.ts"],"sourcesContent":["import lodash from 'lodash'\n\nimport { Configs } from '../../types'\n\nconst { each, setWith } = lodash\n\nconst convertToNested = (object: Configs) => {\n\n  const nested: Configs = {}\n\n  each(object, (value, key) => {\n    setWith(nested, key, value, Object)\n  })\n\n  return nested\n}\n\nexport { convertToNested }\n","import lodash from 'lodash'\n\nimport type { Configs, NestedConfigs } from '../../types'\n\nconst { has } = lodash\n\nconst createConfigs = (obj: NestedConfigs): Configs => {\n\n  function walk(into, obj, prefix = []) {\n    Object.entries(obj).forEach(([key, val]) => {\n      if (typeof val === `object` && !Array.isArray(val) && !has(val, `default`)) walk(into, val, [...prefix, key]);\n      else into[[...prefix, key].join(`.`)] = val;\n    });\n  }\n\n  const dotObj = {};\n  walk(dotObj, obj);\n\n  return dotObj;\n}\n\nexport { createConfigs }\n","import lodash from 'lodash'\n\nimport type {\n  Config,\n  Configs,\n} from '../../types'\n\nconst { each, isBoolean, isObject, last, split, startsWith, trimEnd } = lodash\n\n/**\n * TODO: This function doesn't know how to handle configs with an empty array value (preSelectedNewsletters) and the config will just be ignored\n */\nconst flattenJsonObject = (object: object, initialPathPrefix: string = ``) => {\n\n  function flatten(object, initialPathPrefix) {\n    if (!object || typeof object !== `object`) {\n      return [{ [initialPathPrefix]: object }]\n    }\n\n    const prefix = initialPathPrefix\n      ? Array.isArray(object)\n        ? initialPathPrefix\n        : `${initialPathPrefix}.`\n      : ``\n\n    return Object.keys(object)\n      .flatMap((key) =>\n        flatten(\n          object[key],\n          Array.isArray(object) ? `${prefix}[${key}]` : `${prefix}${key}`,\n        ),\n      )\n      .reduce((acc, path) => ({ ...acc, ...path }), [])\n  }\n\n  const flattenedObject = flatten(object, initialPathPrefix)\n\n  const configs = {}\n  each(flattenedObject, (value, key) => {\n    const splitKey = split(key, `.`)\n    const lastPart = last(splitKey)\n    if (startsWith(lastPart, `#`)) {\n      if (lastPart === `#value`) {\n        configs[trimEnd(key, `.#value`)] = value\n      }\n    } else {\n      configs[key] = value\n    }\n  })\n\n  return configs\n}\n\nconst createConfigsFromJson = (json: object): Configs => {\n\n  const configs = {}\n\n  const flattenJson = flattenJsonObject(json)\n\n  each(flattenJson, (value, key) => {\n\n    let defaultValue = value\n    if (isObject(value)) {\n      defaultValue = value[`#value`]\n    }\n\n    const config: Config = {\n      default: defaultValue,\n    }\n\n    if (isBoolean(defaultValue)) {\n      config.type = `switch`\n    }\n\n    configs[key] = config\n  })\n\n  return configs\n}\n\nexport { createConfigsFromJson }\n","import lodash from 'lodash'\n\nimport type { Configs, NestedConfigs } from '../../types'\nimport { createConfigs } from './createConfigs'\n\nconst { map } = lodash\n\nconst createGroup = (group: string, configs: NestedConfigs): Configs => {\n\n  const groupedConfigs = createConfigs(configs)\n\n  map(groupedConfigs, config => {\n    if (typeof config === `object`) {\n      config.group = group\n    }\n    \n    return config\n  })\n\n  return groupedConfigs\n}\n\nexport { createGroup }\n","import lodash from 'lodash'\n\nimport type { Config, Configs, NestedConfigs } from '../../types'\nimport { createGroup } from './createGroup'\n\nconst { assign, has, isBoolean, isObject, map, mapValues, merge, size } = lodash\n\nconst createFeature = (group: string, enabled: boolean | Config, configs: NestedConfigs = null): Configs => {\n\n  let enabledKey = null\n  \n  const configSize = typeof configs === `object` && size(configs) || -1\n\n  if (configSize !== 1) {\n    throw new Error(`The \"${group}\" group must only have one parent key, ${configSize} given.`)\n  }\n\n  const modifiedConfigs = typeof configs === `object` && mapValues(configs, (config, key) => {\n    if (!enabledKey) {\n\n      let enabledConfig = {\n        type: `switch`,\n        default: enabled,\n      }\n\n      if (isObject(enabled)) {\n        if (!has(enabled, `default`) || !isBoolean(enabled.default)) {\n          throw new Error(`A \"default\" boolean value must be supplied in the object`)\n        }\n\n        merge(enabledConfig, enabled)\n      }\n\n      config = assign({ enabled: enabledConfig }, config)\n      enabledKey = `${key}.enabled`\n    }\n\n    return config\n  })\n\n  let groupedConfigs = createGroup(group, modifiedConfigs)\n\n  map(groupedConfigs, (config, key) => {\n    if (typeof config === `object` && key !== enabledKey) {\n      config.visibleIf = enabledKey\n    }\n\n    return config\n  })\n\n  return groupedConfigs\n}\n\nexport { createFeature }\n","import lodash from 'lodash'\n\nimport type { Configs, NestedConfigs } from '../../types'\nimport { createGroup } from './createGroup'\n\nconst { has, map, mapKeys } = lodash\n\nconst createField = (keyPrefix: string, callback = null): Configs => {\n\n  let fields: Configs = {}\n\n  const visibleIf = `${keyPrefix}.isVisible`\n\n  fields[`isVisible`] = {\n    type: `switch`,\n    label: `Visible`,\n    default: true,\n    group: keyPrefix,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`required`] = {\n    type: `switch`,\n    label: `Required`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`disabled`] = {\n    type: `switch`,\n    label: `Disabled`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`readonly`] = {\n    type: `switch`,\n    label: `Readonly`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`hasAutoFocus`] = {\n    type: `switch`,\n    label: `Autofocus`,\n    default: false,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-2`,\n  }\n\n  fields[`pattern`] = {\n    type: `input`,\n    label: `Pattern`,\n    default: ``,\n    group: keyPrefix,\n    visibleIf: visibleIf,\n    styleClasses: `col-md-12`,\n  }\n\n  if (callback) {\n    fields = callback(fields)\n\n    map(fields, (subField, key) => {\n      if (typeof subField === `object` && !has(subField, `group`)) {\n        subField.group = keyPrefix\n      }\n      \n      if (typeof subField === `object` && key !== `isVisible` && !has(subField, `visibleIf`)) {\n        lodash.set( subField, `visibleIf`, visibleIf )\n      }\n      if (typeof subField === `object` && !has(subField, `styleClasses`)) {\n        subField.styleClasses = `col-md-12`\n      }\n    })\n  }\n\n  const nestedConfigs = mapKeys(fields, (_, key) => {\n    return `${keyPrefix}.${key}`\n  }) as NestedConfigs\n\n  return createGroup(keyPrefix, nestedConfigs)\n}\n\nexport { createField }\n","import lodash from 'lodash'\n\nimport type {\n  ConfigCategory,\n  Configs,\n  Section,\n} from '../../types'\n\nconst { merge } = lodash\n\nconst createSection = (configs: Configs, categoryName: ConfigCategory = null, sectionName: string = null, override: object = null): Section => {\n\n  const section: Section = {\n    configs: {},\n  }\n\n  if (configs) {\n    section.configs = configs\n  }\n\n  if (categoryName) {\n    section.category = categoryName\n  }\n\n  if (sectionName) {\n    section.section = sectionName\n  }\n\n  if (override) {\n    merge(section, override)\n  }\n\n  return section\n}\n\nexport {\n  createSection,\n}\n","import lodash from 'lodash'\n\nimport type {\n  Configs,\n} from '../../types'\n\nconst { mapValues, merge } = lodash\n\nconst createSubSection = (configs: Configs, subsectionName: string): Configs => {\n\n  return mapValues(configs, config => {\n    merge(config, {\n      subsection: subsectionName,\n    })\n\n    return config\n  })\n}\n\nexport {\n  createSubSection,\n}\n","import lodash from 'lodash'\n\nimport type {\n  Configs,\n  Onboarder,\n  OnboarderFields,\n  OnboarderTab,\n} from '../../types'\n\nconst { assign, has, map, mapValues, setWith } = lodash\n\nconst generateModel = schema => {\n\n  const data = {}\n\n  map(schema, tab => {\n    map(tab.fields, field => {\n      setWith(data, field.model, field.default, Object)\n    })\n  })\n\n  return data\n}\n\nconst transformFields = (fields: OnboarderFields, configs: Configs) => {\n\n  return fields.map(field => {\n\n    const key = typeof field === `string` ? field : lodash.get( field, `key` )\n\n    if (has(configs, key)) {\n      const overrides = typeof field === `object` ? field : {}\n      delete overrides.key\n\n      return assign({\n        model: key,\n      }, configs[key], overrides)\n    }\n\n    console.log(`${key} is not a config!`)\n\n    return null\n  }).filter(field => {\n    if (field !== null) {\n      return field\n    }\n  })\n}\n\nconst parseSchema = (onboarder: Onboarder, configs: Configs) => {\n\n  return mapValues(onboarder, (tab, index) => {\n\n    const tabObj: OnboarderTab = {\n      id: index,\n      order: Number(index),\n      label: tab.label,\n      fields: transformFields(tab.fields, configs),\n    }\n\n    return tabObj\n  })\n\n}\n\nconst parseOnboarder = (name: string, onboarder: Onboarder, configs: Configs) => {\n\n  const obj: any = {\n    name: name,\n    schema: [],\n    model: {},\n  }\n\n  if (onboarder) {\n    const schema = parseSchema(onboarder, configs)\n\n    obj.schema = schema\n    obj.model = generateModel(schema)\n  }\n\n  return obj\n}\n\nexport { parseOnboarder }\n","import lodash from 'lodash'\nimport { Components } from 'swagger-jsdoc'\n\nimport type { ComponentOptions, Config, ConfigObject, Configs, Source, StandardizedConfigs } from '../../types'\nimport { convertToNested } from './convertToNested'\n\nexport type SourceConfigs = { \n  getComponents?: () => Promise<Components>, \n  getConfigs?: () => Promise<Configs>, \n  getLabel?: () => string | Promise<string | undefined>, \n  getName?: () => string | Promise<string | undefined>, \n  source?: string\n}\n\nexport type HelperFunctions = ReturnType<typeof getHelpers>\n\nexport type Definitions = {\n  [key: string]: DefinitionComponent\n}\n\n/* eslint-disable no-unused-vars */\nexport type DefinitionComponent = {\n  getConfigs?: (_: HelperFunctions) => Configs\n  getSettings?: (_: HelperFunctions) => Configs\n  getTranslations?: (_: HelperFunctions) => Configs\n  getUI?: (_: HelperFunctions) => Configs\n}\n/* eslint-enable no-unused-vars */\n\nconst { assign, each, get, has, isObject, kebabCase, last, mapKeys, mapValues, merge, set, size, split, startCase, unset } = lodash\n\nconst getType = (config: Config) => {\n  if (typeof config === `object`) {\n     switch (typeof config.default) {\n      case `boolean`:\n        return `switch`\n    }\n  }\n\n  return `input`\n}\n\nconst standardizeConfig = (key: string, config: Config, skipDefaultCheck = false) => {\n\n  if (isObject(config)) {\n    if (!skipDefaultCheck && !has(config, `default`)) {\n      throw new Error(`Config \"${key}\" is missing a \"default\" value.`)\n    }\n  } else {\n    config = {\n      default: config,\n    }\n  }\n\n  return config as ConfigObject\n}\n\nconst parseConfig = (key: string, config: Config, options: Partial<ConfigObject> = {}) => {\n\n  config = standardizeConfig(key, config)\n\n  delete config.key\n\n  if (config.docLink) {\n    const docLinkText = `Documentation on this feature can be found <a href=\"${config.docLink}\">here</a>.`\n    config.hint = config.hint ? docLinkText + `<br>${config.hint}` : docLinkText\n    delete config.docLink\n  }\n\n  return assign({\n    default: null, // This is placed here so that `default` appears as first property\n    type: getType(config),\n    label: startCase(last(split(key, `.`))),\n    category: `setting`,\n  } as ConfigObject, config, options) as ConfigObject\n}\n\nconst parseConfigs = (\n  configs: Configs, \n  options: Partial<ConfigObject> = {}, \n  // eslint-disable-next-line no-unused-vars\n  callback?: (key: string, config: Config) => void,\n) => {\n\n  configs = mapKeys(configs, (config: Config, key: string) => {\n    return lodash.get(config, `key`, key)\n  })\n\n  return mapValues(configs, (config: Config, key: string) => {\n\n    callback && callback(key, config)\n\n    return parseConfig(key, config, options)\n  }) as StandardizedConfigs\n}\n\nconst parseUniqueConfigs = (set: Configs, configs: Configs, options: Partial<ConfigObject>) => {\n  return parseConfigs(configs, options, (key) => {\n    if (has(set, key)) {\n      throw new Error(`Duplicate key: \"${key}\"`)\n    }\n  })\n}\n\nconst parseConfigsIntoCollection = (set: Configs, configs: Configs, options: Partial<ComponentOptions>) => {\n  merge(set, parseUniqueConfigs(set, configs, options))\n}\n\nconst getHelpers = (components: Components, component: string) => {\n\n  const groupTypes = {\n    group: {\n      path: `groups`,\n    },\n    tab: {\n      path: `tabs`,\n    },\n  }\n\n  const walkConfigs = (configs: Configs, callback = null) => {\n\n    const walked: StandardizedConfigs = {}\n\n    each(configs, (config, key) => {\n      config = standardizeConfig(key, config)\n      if (callback) {\n        const {\n          config: newConfig,\n          key: newKey,\n        } = callback(key, config)\n        walked[newKey] = newConfig\n      } else {\n        walked[key] = config\n      }\n    })\n\n    return walked\n  }\n\n  const setComponentGroup = (name: string, label: string, configs: Configs, type = `group`) => {\n\n    let path: string = groupTypes[type].path\n    let replacement: ComponentOptions = {}\n\n    each(configs, config => {\n      if (typeof config === `object` && config.group) {\n\n        // TODO: This variable should handle cases where group value is deeply nested\n        const groupExpanded = config.group\n\n        each(groupTypes, groupType => {\n          const group = get(components, [component, groupType.path, groupExpanded])\n          if (group) {\n            set(replacement, [groupType.path, groupExpanded], group)\n            unset(components, [component, groupType.path, groupExpanded])\n\n            const holder = get(components, [component, groupType.path], {})\n            if (size(holder) === 0) {\n              unset(components, [component, groupType.path])\n            }\n          }\n        })\n      }\n    })\n\n    // TODO: Need to think about this more\n    // if (has(components, [component, path, name])) {\n    //   throw new Error(`Duplicate ${type}: \"${name}\"`)\n    // }\n\n    set(components, [component, path, name], assign({\n      label: label,\n    }, replacement))\n  }\n\n  const addNested = (name: string, configs: Configs) => {\n    return walkConfigs(configs, (key: string, config: Config) => {\n\n      if (typeof config === `object`) {\n        if (config.visibleIf) {\n          config.visibleIf = `${name}.${config.visibleIf}`\n        }\n      }\n\n      return {\n        key: `${name}.${key}`,\n        config,\n      }\n      \n    })\n  }\n\n  const addGroup = (\n    name: string, \n    label: string, \n    configs: Configs, \n    nesting = true, \n    type = `group`, \n    /* eslint-disable-next-line no-unused-vars */  \n    callback?: (_: string, _2: Config) => void,\n  ) => {\n    setComponentGroup(name, label, configs, type)\n\n    return walkConfigs(configs, (key: string, config: ConfigObject) => {\n      config.group = config.group ? `${name}.${config.group}` : name\n\n      if (callback) {\n        callback(key, config)\n      }\n\n      return {\n        key: nesting ? `${name}.${key}` : key,\n        config,\n      }\n    })\n  }\n\n  const addFeature = (name: string, label: string, configs: Configs, enabled = false, nesting = true) => {\n\n    if (has(configs, `enabled`)) {\n      throw new Error(`Feature \"${name}\" should not contain a property named \"enabled\".`)\n    }\n\n    configs = assign({\n      enabled: standardizeConfig(`enabled`, enabled),\n    }, configs)\n\n    configs = addGroup(name, label, configs, nesting, `group`, (key, config) => {\n      if (key !== `enabled`) {\n        typeof config === `object` && lodash.set( config, `visibleIf`, `${name}.enabled` )\n      }\n    })\n\n    return configs as StandardizedConfigs\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  type AddFieldCallbackInnerFuncType = (key: string, config: Config ) => void\n\n  const addField = (\n    key: string, \n    // eslint-disable-next-line no-unused-vars\n    callback?: (arg: { insert: AddFieldCallbackInnerFuncType, modify: AddFieldCallbackInnerFuncType }) => void,\n  ) => {\n\n    let fields: Configs = {}\n\n    const visibleIf = `${key}.isVisible`\n\n    fields.isVisible = {\n      default: true,\n      label: `Visible`,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.required = {\n      default: false,\n      label: `Required`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.disabled = {\n      default: false,\n      label: `Disabled`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.readonly = {\n      default: false,\n      label: `Readonly`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.hasAutoFocus = {\n      default: false,\n      label: `Autofocus`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-2`,\n    }\n\n    fields.pattern = {\n      default: ``,\n      label: `Pattern`,\n      visibleIf: visibleIf,\n      styleClasses: `col-md-12`,\n    }\n\n    if (callback) {\n\n      const insert: AddFieldCallbackInnerFuncType = (key, config) => {\n\n        if (has(fields, key)) {\n          throw new Error(`Field ${key} already exists!`)\n        }\n\n        fields[key] = parseConfig(key, config, {\n          visibleIf: visibleIf,\n          styleClasses: `col-md-12`,\n        })\n      }\n\n      const modify: AddFieldCallbackInnerFuncType = (key, config) => {\n        merge(fields[key], standardizeConfig(key, config, true))\n      }\n\n      callback && callback({\n        insert,\n        modify,\n      })\n    }\n\n    return addGroup(key, startCase(key), fields, true)\n  }\n\n  const addTab = (label: string, configs: Configs) => {\n\n    const name = kebabCase(label)\n\n    return addGroup(name, label, configs, false, `tab`)\n  }\n\n  return {\n    addNested,\n    addFeature,\n    addGroup,\n    addTab,\n    addField,\n  }\n}\n\nconst parseConfigsAndComponents = (definitions: Definitions) => {\n\n  const configs: Configs = {}\n  const components = parseComponents(definitions)\n\n  each(definitions, (component, key) => {\n\n    const {\n      getConfigs,\n      getSettings,\n      getTranslations,\n      getUI,\n    } = component\n\n    const options: Partial<ConfigObject> = {\n      component: key,\n    }\n\n    const helpers = getHelpers(components, key)\n\n    if (getConfigs) {\n      parseConfigsIntoCollection(configs, getConfigs(helpers), options)\n    } else {\n\n      if (getSettings) {\n        parseConfigsIntoCollection(configs, getSettings(helpers), assign(options, {\n          category: `setting`,\n        }))\n      }\n\n      if (getTranslations) {\n        parseConfigsIntoCollection(configs, getTranslations(helpers), assign(options, {\n          category: `translation`,\n        }))\n      }\n\n      if (getUI) {\n        parseConfigsIntoCollection(configs, getUI(helpers), assign(options, {\n          category: `ui`,\n        }))\n      }\n    }\n  })\n\n  return {\n    configs,\n    components,\n  }\n}\n\nconst parseComponent = (key: string, component?: ComponentOptions) => {\n  return assign({\n    label: startCase(last(split(key, `.`))),\n    order: 0,\n    toggleable: false,\n    description: null,\n    rootKey: null,\n  }, component) as ComponentOptions\n}\n\nconst parseComponents = (components: Components) => {\n  return mapValues(components, (component, key: string) => {\n    const { getOptions } = component\n\n    return parseComponent(key, getOptions ? getOptions() : null)\n  }) as Components\n}\n\nconst parseComponentsFromConfigs = (configs: Configs, structure: Components = {}) => {\n\n  // TODO: Place all these types in the \"types\" directory\n  const components: Components = {}\n\n  let hasUnsorted = false\n\n  each(configs, config => {\n    if (typeof config === `object` && has(config, `component`)) {\n      if (!has(components, config.component)) {\n\n        let options = {}\n        if (has(structure, config.component)) {\n          const { getOptions } = structure[config.component]\n          options = getOptions ? getOptions() : structure[config.component]\n        }\n\n        components[config.component] = parseComponent(config.component, options)\n      }\n    } else {\n      hasUnsorted = true\n    }\n  })\n\n  if (hasUnsorted && size(components)) {\n    components.unsorted = parseComponent(`unsorted`, {\n      order: 999,\n    })\n  }\n\n  return components\n}\n\nconst parseSource = async ({ getComponents, getConfigs, getLabel, getName, source }: SourceConfigs) => {\n\n  const name = getName ? await getName() : source\n  const label = getLabel ? await getLabel() : startCase(name)\n\n  const options: Source = {\n    name,\n    label,\n  }\n\n  const grabComponents = getComponents ? await getComponents() : null\n\n  if (getConfigs) {\n    const config = parseConfigs(await getConfigs())\n    const components = parseComponentsFromConfigs(config, grabComponents)\n    merge(options, {\n      config,\n      components,\n    })\n  } else {\n    const { components, configs } = parseConfigsAndComponents(grabComponents)\n    merge(options, {\n      configs,\n      components,\n    })\n  }\n\n  return options\n}\n\n// This should be renamed parseSections (assuming we still need it)\n// const parseConfigs = (source: string, sections) => {\n\n//   const configs: Configs = {}\n\n//   const configKeys = []\n\n//   each(sections, (section, sectionKey) => {\n//     each(section.configs, (config: Config, key: string) => {\n\n//       const finalKey = config.key || key\n//       const finalSection = section.section || sectionKey\n//       const finalCategory = section.category || `setting`\n\n//       if (includes(configKeys, finalKey)) {\n//         throw new Error(`Source \"${source}\" has config with duplicate key \"${finalKey}\". No duplicate keys allowed.`)\n//       } else {\n//         configKeys.push(finalKey)\n//       }\n\n//       const configObj = {\n//         default: null,\n//         type: `input`,\n//         label: startCase(last(split(finalKey, `.`))),\n//         reference: finalKey,\n//         section: finalSection,\n//         category: finalCategory,\n//       }\n\n//       config = assign(configObj, config)\n\n//       configs[finalKey] = config\n//     })\n//   })\n\n//   return configs\n// }\n\nconst getMockResponse = (configs, options = null) => {\n\n  options = assign({\n    nested: false,\n  }, options)\n\n  const data = {}\n\n  each(configs, (config, key) => {\n    data[key] = config.default\n  })\n\n  if (options.nested) {\n    return convertToNested(data)\n  }\n\n  return data\n}\n\nclass SourceError extends Error {\n\n  constructor(source, error) {\n    super(`${error.message} (\"${source}\" source)`)\n    this.name = `SourceError`\n  }\n}\n\nexport { getMockResponse, parseSource, SourceError }\n"],"names":["each","lodash","setWith","convertToNested","object","nested","value","key","Object","has","createConfigs","obj","dotObj","walk","into","prefix","entries","forEach","_ref","val","Array","isArray","join","isBoolean","isObject","last","split","startsWith","trimEnd","map","createGroup","group","configs","groupedConfigs","config","assign","mapValues","merge","size","mapKeys","transformFields","fields","field","get","overrides","model","console","log","filter","kebabCase","set","startCase","unset","getType","standardizeConfig","skipDefaultCheck","Error","default","parseConfig","options","docLink","docLinkText","hint","type","label","category","parseConfigs","callback","parseConfigsIntoCollection","parseUniqueConfigs","parseComponent","component","order","toggleable","description","rootKey","SourceError","_Error","source","error","_this","call","this","message","name","json","flattenJson","initialPathPrefix","flattenedObject","flatten","keys","flatMap","reduce","acc","path","_extends","splitKey","lastPart","flattenJsonObject","defaultValue","enabled","enabledKey","configSize","modifiedConfigs","enabledConfig","visibleIf","keyPrefix","styleClasses","subField","nestedConfigs","_","categoryName","sectionName","override","section","subsectionName","subsection","data","onboarder","schema","tab","index","id","Number","parseSchema","generateModel","parseSource","getComponents","getConfigs","getLabel","getName","_temp5","_temp3","_temp2","grabComponents","_temp","Promise","resolve","then","_getConfigs","components","structure","hasUnsorted","getOptions","unsorted","parseComponentsFromConfigs","definitions","_parseConfigsAndCompo","parseComponents","getSettings","getTranslations","getUI","helpers","groupTypes","walkConfigs","walked","_callback","addGroup","nesting","replacement","groupExpanded","groupType","holder","setComponentGroup","addNested","addFeature","addTab","addField","isVisible","required","disabled","readonly","hasAutoFocus","pattern","insert","modify","getHelpers","e","reject"],"mappings":"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"}